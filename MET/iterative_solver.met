#~
    Column storage matrix, aka multivector
~#
class MatVecList[T,ST=SizeType] inherits MatAncestor
    property is_a_MatVecList
    static const known_nb_values := false
    static const static_nb_rows := -1
    static const static_nb_cols := -1
    data := SplittedVec[Vec[T],4]() #~ @optimize : use bloc matrices ? ~#
    
    #
    def get_nb_cols                       return data.size
    def get_nb_rows                       return data[0].size
    def select( i, j )                    return data[j][i]
    def push_back(v)                      data.push_back(v)
    def select(i) when i.tensor_order<=0  return data[i]
    def __for__(block)                    data.__for__(block)
    def get_last_item                     return data.last_item
    def col(i) pertinence 2               return data[i] 
    #
    def mul (v) when v.tensor_order == 1
        out := Vec[T]( size = data[0].size, default_values = 0 )
        for i in 0..data.size
            out += v[i] * data[i]


#
def mul(a,b) when (b.is_a_MatVecList and not (a.is_a_MatTrans and a.mat->is_a_MatVecList)) pertinence 5
    out := b
    for w in out 
        w = a*w
    return out
#
def mul(a,b) when (b.is_a_MatVecList and a.is_a_MatTrans and a.mat->is_a_MatVecList) pertinence 5
    out := Mat[T = b.T, ST= b.ST](nb_rows = a.mat->nb_cols, nb_cols = b.nb_cols)
    for i in 0..out.nb_rows
        for j in 0..out.nb_cols
            out[i,j] = dot ( a.mat->col(i) , b.col(j) ) 
    return out
#~
    Basic GramSchmidt // more flexible storage will be studied later
~#
class GramSchmidt[ T, normalized, euclidian, TVECLIST = MatVecList[T,ST]  ]
    property is_a_gramschmidt
    static const TypeNormList := [Vec[T],VecCst[value=T(1)]]
    
    vec_list := TVECLIST()
    a_vec_list := RefIf[ TVECLIST, euclidian ]()
    norm_list := TypeNormList[normalized]()
    ortho_keep_ := 1024
    older_vec_index := 0
    
    #
    def write_to_stream(f)
        f<<<join(vec_list,"\n")
    #
    def mul( v ) when v.tensor_order==1
        ret := Vec[T](vec_list[0]*v[0])
        for i in 1..v.size
            ret += vec_list[i] * v[i]
        return ret
    #
    def init
        init_using_default_values( self )
        a_vec_list.init(vec_list)
    #
    def init( val )
        init_using_default_values( self )
        a_vec_list.init( vec_list )
    #
    def add_vec(vec)
        if vec_list.nb_cols == ortho_keep
            vec_list[ older_vec_index++ ] = vec
            older_vec_index %= ortho_keep_
        else
            vec_list.push_back( vec )
    #
    def add_vec(vec, n_vec)
        if vec_list.nb_cols == ortho_keep
            vec_list[ older_vec_index++ ] = vec
            older_vec_index %= ortho_keep_
        else
            vec_list.push_back( vec )
    #
    def add_vec( vec, a_vec , n_vec)
        if normalized
            toto := 1/sqrt(n_vec)
            vec *= toto
            a_vec *= toto
            if vec_list.nb_cols == ortho_keep_
                vec_list[ older_vec_index ] = vec
                (@a_vec_list)[ older_vec_index++ ] = a_vec
                older_vec_index %= ortho_keep_
            else
                vec_list.push_back( vec )
                (@a_vec_list).push_back( a_vec )
        else
            if vec_list.nb_cols == ortho_keep_
                vec_list[ older_vec_index ] = vec
                (@a_vec_list)[ older_vec_index ] = a_vec
                norm_list[ older_vec_index++ ] = n_vec
                older_vec_index %= ortho_keep_
            else
                vec_list.push_back( vec )
                (@a_vec_list).push_back( a_vec )
                norm_list.push_back( n_vec )
    #
    def get_ortho_keep
        return ortho_keep_
    #
    def reassign_ortho_keep( val )
        ortho_keep_ = val
        assert( ortho_keep_ >= vec_list.nb_cols, "TODO -> change ortho_keep" )
#
def mul(a,b) when ( a.is_a_gramschmidt ) and b.tensor_order==1
    return(a.mul(b))
#~
    Classical GramSchmidt // would be optimized with a column-matrix storage
    Fastest and least robust
~#
class ClassicalGramSchmidt[ T, normalized, euclidian, TVECLIST = MatVecList[T] ] inherits GramSchmidt[ T, normalized, euclidian, TVECLIST ]
    def orthogonalize( vec )
        tmp := Vec[T]()
        orthogonalize( vec, tmp )
    #
    def orthogonalize( vec , tmp )
        tmp.size = vec_list.nb_cols
        for i in 0..vec_list.nb_cols
            tmp[i] = dot ( (@a_vec_list)[i] , vec ) / norm_list[i]
        for i in 0..vec_list.nb_cols
            vec -= tmp[i] * vec_list[i]

#~
    Modified GramSchmidt // perfectly suited to list of vectors
    Less fast and more robust
~#
class ModifiedGramSchmidt[ T, normalized, euclidian, TVECLIST = MatVecList[T] ] inherits GramSchmidt[ T, normalized, euclidian, TVECLIST ]
    def orthogonalize( vec )
        vt := Vec[T]()
        orthogonalize( vec, vt )
    #
    def orthogonalize( vec , vt )
        vt.size = vec_list.nb_cols
        for i in 0..vec_list.nb_cols
            vt[i] = dot( (@a_vec_list)[i] , vec ) / norm_list[i]
            vec -= vt[i] * vec_list[i]
#~
  Projector :
    data : 
        operator A
        constraint : C 
    two cases (bool C_is_kernel)
        Ker(P)=C ->  P := I - C (C^T A C)^(-1) C^T A
        Ker(P)=AC P := I - A C (C^T A C)^(-1) C^T
~#
class Projector[ T, TOp, C_is_kernel, TVECLIST = MatVecList[T] ]
    property is_a_projector
    C := TVECLIST()
    coarse_matrix := InternalVariable() # Mat[T, [Gen,Sym][TOp::is_sym] ]()
    AC := TVECLIST()
    A := InternalVariable()
    #
    def init( oper, constraint )
        init_using_default_values( self )
        A.init_using_var( oper )
        C.init(constraint)
        if C.nb_cols != 0
            if C_is_kernel
                AC.init(@A' * C)
                coarse_matrix.init_using_var(inv(Mat[T, [Gen,Sym][TOp::is_sym] ]( AC' * C )))
            else
                AC.init(@A * C)
                coarse_matrix.init_using_var(inv(Mat[T, [Gen,Sym][TOp::is_sym] ]( C' * AC )))
    #
    def mul( b )
        if C.nb_cols == 0
            return b
        else
            if C_is_kernel
                return ( b - ( C * ( @coarse_matrix * ( AC' * b ) ) ) )
            else
                return ( b - ( AC * ( @coarse_matrix * ( C' * b ) ) ) )
#
class ProjectorTrans
    property is_a_projector
    p := InternalVariable()
    def init(PP)
        p.init_using_var(PP)
    def mul(b)
        if p->C.nb_cols == 0
            return b
        else
            if p->C_is_kernel
                return ( b - ( p->AC * ( @p->coarse_matrix' * ( p->C'* b ) ) ) )
            else
                return ( b - ( p->C * ( @p->coarse_matrix' * ( p->AC' * b) ) ) ) 
#
def trans(P) when P.is_a_projector
    return ProjectorTrans(P)
#
def mul(a,b) when ( a.is_a_projector ) and b.tensor_order==1
    return(a.mul(b))
#~
  Iterative Solver :    
    solves 
( oper   G )   ( sol )   ( rhs )
(          ) * (     ) = (     )
( G'     0 )   ( y_g )   ( e_g )
    with preconditioner prec and augmentation C
~#
class IterativeSolver[ TA, TPC, T, ST , TVECLIST = MatVecList[T] ]
    static const Tvec := Vec[ T ]
    nb_iteration_min := 0
    nb_iteration_max := Int32::max_representable
    nb_iteration_stagnation := 100 # nb iteration ...
    convergence_criterion := T(0)
    oper := InternalVariable()
    prec := InternalVariable()
    sol := Tvec()
    rhs := Tvec()
    y_g := Tvec()
    e_g := Tvec() 
    PG := Projector[ T , TPC, false ]()
    PC := Projector[ T , TA, true ]()
    #
    def init( A, M, G_ = TVECLIST(), C_=TVECLIST() , M_ = M )
        init_using_default_values( self )
        oper.init_using_var( A )
        prec.init_using_var( M )
        sol.init( size = oper->nb_rows, default_value = 0 )
        rhs.init( size = oper->nb_cols )
        y_g.init( size = G_.nb_cols )
        e_g.init( size = G_.nb_cols )
        PG.init( M_ , G_ )
        PC.init( A , PG * C_ )
    #
    def correct_initial_value()
        if PG.C.nb_cols > 0
            sol = ( PG * sol ) + ( PG.AC * ( @PG.coarse_matrix * e_g ) )
    #            info ( PG.C' * sol ) - e_g
        if PC.C.nb_cols > 0
            sol = ( PC * sol ) + ( PC.C * ( @PC.coarse_matrix * ( PC.C' * rhs ) ) )
    #
    def complete_solution()
        if PG.C.nb_cols > 0
            y_g = @PG.coarse_matrix * ( PG.AC' * (rhs - @oper * sol) )
    #
    def verify_solution()
        tmp := @oper * sol - rhs
        tmp2 := Vec[T]()
        if PG.C.nb_cols > 0 
            tmp += PG.C * y_g
            tmp2 = PG.C' * sol
            info norm_2( tmp2 )
        return norm_2(tmp)
#~
    Krylov solvers subclass, characterized by the storage of the subspace
~#
class KrylovSolver[ TA, TPC, T = TA::T, ORTHOGONALIZER = ModifiedGramSchmidt, ST = TA::ST ] inherits IterativeSolver[ TA,TPC, T, ST ]
    subspace := ORTHOGONALIZER[T]()

#~
  Conjugate Gradient, to use in the case of symetric definite positive operator and preconditioner
  slight non-positivity of the operator can be tolerated
~#
class ConjugateGradient[ TA, TPC , T = TA::T, ORTHOGONALIZER = ClassicalGramSchmidt, ST = TA::ST ] inherits KrylovSolver[ TA, TPC, T, ORTHOGONALIZER[normalized = true, euclidian = false], ST ]
    def solve()
        correct_initial_value()
        res := Tvec()
        res.init( size = oper->nb_cols )
        res = PG' * ( rhs - @oper * sol ) # optimiser : si &PG.A == prec alors PG' = identity
        prec_res := PC * ( PG * ( @prec * res ) )
        a_research_direction := PG' * ( @oper * prec_res )
        a_norm := dot( a_research_direction, prec_res )
        if a_norm < convergence_criterion 
            complete_solution()
            break
        subspace.add_vec( prec_res, a_research_direction, a_norm )
        alpha := dot( prec_res, res ) / subspace.norm_list.last_item
        while alpha > convergence_criterion
            info alpha
            sol += alpha * subspace.vec_list.last_item
            res -= alpha * a_research_direction
            prec_res = PC * ( PG * ( @prec * res ) )
            subspace.orthogonalize(prec_res)
            a_research_direction = PG' * ( @oper * prec_res )
            a_norm = dot( a_research_direction, prec_res )
            if a_norm < convergence_criterion break
            subspace.add_vec( prec_res, a_research_direction, a_norm )
            alpha = dot( prec_res, res ) / subspace.norm_list.last_item
        complete_solution()
#~
    GMRes solver suited to any invertible matrix
~#
class GMRes[TA, TPC ,T = TA::T, ORTHOGONALIZER = ModifiedGramSchmidt, ST = TA::ST ] inherits KrylovSolver[ TA, TPC , T, ORTHOGONALIZER[ euclidian = true, normalized = true ], ST]
    def solve()
        correct_initial_value()
        v := Vec[T](PC * (PG * (@prec * ( PG' * (rhs - @oper * sol)))))
        beta := Vec[T](size = subspace.ortho_keep)
        givens := Vec[T](size = subspace.ortho_keep)
        hessem := Mat[T,TriSup](subspace.ortho_keep) ; hessem = 0
        beta[0] = norm_2(v)
        if beta[0] < convergence_criterion 
            complete_solution()
            break
        v /= beta[0]
        subspace.add_vec( v )
        iter := 0
        ratio := T(1)
        subterm := T(0)
        while ratio > convergence_criterion
            v = PC * (PG * ( @prec * ( PG' * (@oper * v )))) # optimisation si &PG.oper = prec PG' = Id.
            vt := Vec[T]()
            subspace.orthogonalize(v,vt)
            for i in 0..iter+1
                hessem[i,iter] = vt[i]
            subterm = norm_2(v)
            v /= subterm
            subspace.add_vec( v )
            subd ~=Ptr[T]
            for i in 0..iter+1
                if i==iter
                    subd = pointer_on(subterm)
                    givens[iter] = hessem[iter,iter] / sqrt(hessem[iter,iter]**2 + subterm**2)
                else 
                    subd = pointer_on(hessem[i+1,iter])
                tp1 := hessem[i,iter]
                tp2 := @subd 
                hessem[i,iter] = tp1 * givens[i] + tp2 * sqrt(1-givens[i]**2)
                @subd = -tp1 * sqrt (1-givens[i]**2) + tp2 * givens[i]
            beta[iter+1] = -beta[iter] * sqrt(1-givens[iter]**2)
            beta[iter] *= givens[iter]
            ratio *= abs(sqrt(1-givens[iter]**2))
            info ratio
            iter++
        #computation of the solution
        hessem2 := Mat[T,TriSup](hessem[0..iter])
        beta2 := Vec[T](beta[0..iter])
        y := hessem2 \ beta2
        sol += subspace * y
        complete_solution()

def conjugate_gradient( m, pc, g, c, pp = pc )
    return ConjugateGradient[ type_of(m), type_of(pc) ]( m, pc, g, c, pp )

##
    @relates meca/behavior
    @relates solver/iterative
        
    @tutorial "solver/iterative/toto" depends 
    @endtutorial
    # @f \int_0 x^2 @f
    @a dodjdp
       rpfopfoj
    @ea
    
##
def gmres( m, pc, g, c, pp = pc )
    return GMRes[ type_of(m), type_of(pc) ]( m, pc, g, c, pp )
    def test() # 
        T := Float64
        TM := Mat[Float64,Gen[10,10]]
        stdout.options.precision = 10
        
        m := TM(10,10) ; m = 0;
        g := MatVecList[T]()
        c := MatVecList[T]()
        g.push_back([ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]) 
        c.push_back([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0  ])
        for i in 0..m.nb_rows 
            for j in 0..m.nb_cols
                m[i,j] = i+j
        m.diag += 10 ;
        id := IdentityMatrix()
        cg := gmres( m, id, g, c )
        cg.convergence_criterion = 1e-6
        cg.subspace.ortho_keep = 10
        cg.rhs.values = 10
        cg.e_g.values = 0
        cg.solve()
        info cg.sol
        info cg.y_g
        
        return cg.verify_solution() < 1e-6

namespace test::solver
    list_m_x_b = [ ... ]
    
def test()
    for m,x,b in test::solver::list_m_x_b
        
    @test ""

# --------------------------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------------------------
main()



