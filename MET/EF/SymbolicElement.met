import "ParametricElement.met"

#~
~#
class SymbolicElement[ TE, dim = Int32( TE::points[0].size ), lmtpp = true ]
    static const pe       := ParametricElement[ TE, dim ]()
    static const nb_nodes := pe.nb_nodes
    static const nvi      := pe.nvi # nb interpolation variables
    
    pos_nodes := Vec[ Vec[ Op, dim ], nb_nodes ]()
    var_inter := Vec[ Op, nvi ]()
    name_elem := ""
    
    #
    def init( name_elem = "elem" )
        init_using_default_values( self )
        self.name_elem = name_elem
        letters := "xyztuvw"
        for num_node in 0 .. nb_nodes
            for d in 0 .. dim
                if lmtpp
                    pos_nodes[num_node][d] = symbol( "$name_elem.node($num_node)->pos[$d]", "P_{$num_node}^{$(letters[d])}" )
                else
                    pos_nodes[num_node][d] = symbol("pos[IND($num_node)][$d]","P_{$num_node}^{$(letters[d])}")
        #
        var_inter.init( x => symbol("var_inter[$x]",greek_letter(6+x)) )
        
    def interpolation( val_on_nodes ) return pe.interpolation( var_inter, val_on_nodes )
    def get_pos                       return pe.interpolation( var_inter, pos_nodes )
    def get_jac_mat                   return pe.jac_mat( var_inter, pos_nodes )
    def get_jac                       return pe.jac( var_inter, pos_nodes )
    def get_normal                    return pe.normal( var_inter, pos_nodes )
    def get_measure                   return pe.measure( var_inter, pos_nodes )
    def get_inv_jac_mat               return pe.inv_jac_mat( var_inter, pos_nodes )
    def get_center_of_var_inter       return pe.center_of_var_inter # Ex : Bar -> [1/2]; Triangle -> [1/3 1/3]; ...
    
    # integration
    def integration( expr, mul_by_jac = true, order_diff = 5 )
        res := scalar_conversion( Op, expr )
        if mul_by_jac
            res *= get_jac()
        interval_var_inter := pe.interval_var_inter( var_inter ) 
        for i in ( 0 .. nvi ).reversed
            res = integration( res, var_inter[i], interval_var_inter[i][0], interval_var_inter[i][1], order_diff )
        return res
    
    # mean
    def mean( expr )
        return integration( expr, false ) / integration( Op( 1 ), false )
    
    # helper function -> give a new "field" based on "canonical" interpolation
    def new_variable( name, nb_dim=[], sym = Vec[Op](), interpolation_type = "nodal" ) when interpolation_type == "nodal"
        if nb_dim.size == 0
            vec := Vec[ Op, nb_nodes ]()
            for i in 0 .. vec.size
                s := Op()
                if lmtpp
                    s = symbol("$name_elem.node($i)->$name") # $name_elem.ind[$i].index
                else
                    s = symbol("form.$name.val.template get_val<T>( IND($i) )","$name^{N$i}") # hum !!!
                sym.push_back( s )
                vec[i] = s
            return pe.interpolation( var_inter, vec )
        if nb_dim.size == 1
            d := nb_dim[0]
            vec := Vec[ Vec[Op,d], nb_nodes ]()
            for i in 0 .. nb_nodes
                for j in 0 .. d
                    s := Op()
                    if lmtpp
                        s = symbol("$name_elem.node($i)->$name[$j]","$name^{N$i}_{$j}") # $name_elem.ind[$i].index
                    else
                        s = symbol("form.$name.val.template get_val<V<T,$d> >( IND($i) )[$j]","$name^{N$i}_{$j}") # $name_elem.ind[$i].index
                    sym.push_back( s )
                    vec[i][j] = s
            return Vec[Op,nb_dim[0]]( pe.interpolation( var_inter, vec ) )
        assert( 0, "TODO" )
    
    # helper function -> give a new "field" based on "canonical" interpolation
    def new_variable( name, nb_dim=[], sym = Vec[Op](), interpolation_type = "nodal" ) when interpolation_type == "global"
        if nb_dim.size == 0
            s := symbol("form.$name.val","$name")
            sym.push_back( s )
            return s
        if nb_dim.size == 1
            d := nb_dim[0]
            res := Vec[ Op, d ]()
            for j in 0 .. d
                s := symbol("form.$name.val[$j]","$name_{$j}")
                sym.push_back( s )
                res[j] = s
            return res
        assert( 0, "TODO" )
        
    #
    def make_interpolation( res, interpolation_type, met_name, tex_name ) when interpolation_type == "nodal"
        val_on_nodes := Vec[ type_of( res.val ), nb_nodes ]()
        for num_node in 0 .. nb_nodes
            for ind, val in indices_and_values_of( val_on_nodes[ num_node ] )
                if ind.size
                    j_ind := join( ind, "," )
                    val = symbol( "$met_name[$num_node]($j_ind)", "$(tex_name)_{$j_ind}^{$num_node}" )
                else
                    val = symbol( "$met_name[$num_node]", "$(tex_name)^{$num_node}" )
                res.sym.push_back( val )
        # interpolation
        res.val = interpolation( val_on_nodes )
        
    #
    def grad( tens )
        assert( dim == nvi, "TODO : grad with nb_var_inter != dim ( $nvi != $dim )" )
        #
        inv_jac_  := get_inv_jac_mat()
        res := Tensor[ Op, stat_vec(tens.sizes +++ [ dim ]) ]()
        for ind, val in indices_and_values_of( tens )
            dvi := Vec[ Op, nvi ]( function = val.diff( var_inter[_0] ) )
            tmp := inv_jac_ * dvi # diff / ( X_0, X_1, X_2 ) in jac base
            for d in 0 .. dim
                res[ ind +++ [d] ] = tmp[ d ]
        return res

    #
    def grad_sym( tens ) when tens.tensor_order == 1
        assert( tens.sizes.size==1, "grad_sym works only with tensor_order==1 as input." )
        tmp := self.grad( tens )
        res := Tensor[ Op, stat_vec([tens.sizes[0],tens.sizes[0]]) ]( function = x => 0 )
        for ind, val in res
            val = ( tmp[ ind[0], ind[1] ] + tmp[ ind[1], ind[0] ] ) / 2
        return res

    #
    def div( tens ) when tens.tensor_order == 1
        return sum( grad( tens ).diag )
    
    #
    def var_inter_for_pos( p, nb_iterations = 1 )
        d := p - pos
        return newton_raphson_minimize_iteration_rec( dot(d,d), var_inter, nb_iterations, old_values = get_center_of_var_inter() )

    #
    def point_is_inside( p, nb_iterations = 1 )
        vi := var_inter_for_pos( p, nb_iterations )
        if TE::has_a_var_inter_is_inside_method
            return TE::var_inter_is_inside( vi )
        # -> generic case (not optimized)
        interval_var_inter := pe.interval_var_inter( vi ) 
        res := Op( 1 )
        for interval, var_inter in interval_var_inter, vi
            res *= heaviside( var_inter - interval_var_inter[i][0] )
            res *= heaviside( interval_var_inter[i][1] - var_inter )
        return res
    #
    def var_inter_is_inside( vi, tolerance )
        return TE::var_inter_is_inside( vi, tolerance )
        
