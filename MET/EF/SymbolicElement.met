import "ParametricElement.met"
#~
~#
class SymbolicElementAncestor
    virtual def grad( expr )                                                          abstract
    virtual def grad_sym( expr )                                                      abstract
    virtual def div( expr )                                                           abstract
    virtual def var_inter_for_pos( p, nb_iterations = 1 )                             abstract
    virtual def point_is_inside( p, nb_iterations = 1, tolerance = 0 )                abstract
    virtual def var_inter_is_inside( vi, tolerance = 0 )                              abstract        
    virtual def extrusion_with_normals( normals, alpha )                              abstract
    virtual def var_inter_and_alpha_with_normals( normals, point, nb_iterations = 1 ) abstract
    virtual def projection_with_normals( normals, point, nb_iterations = 1 )          abstract
    virtual def get_shape_functions                                                   abstract
    virtual def get_name                                                              abstract
    virtual def get_nb_dim                                                            abstract
    virtual def children( nvi )                                                       abstract

#~
~#
class SymbolicElement[ TE, dim = Int32( TE::nvi ) ] inherits SymbolicElementAncestor
    static const pe       := ParametricElement[ TE, dim ]()
    static const nb_nodes := pe.nb_nodes
    static const nvi      := pe.nvi # nb interpolation variables
    
    pos_nodes := Vec[ Vec[ Op, dim ], nb_nodes ]()
    var_inter := Vec[ Op, nvi ]()
    name_elem := ""
    _children := Vec[ Vec[ Ptr[ SymbolicElementAncestor ] ], nvi + 1 ]()
    
    assume_const_jac := 0
    
    #
    def destroy
        for i in 1 .. nvi + 1
            for c in _children[ i ]
                delete c
    
    #
    virtual def get_name
        return String( TE )
    
    #
    virtual def get_nb_dim
        return dim
        
    #
    virtual def children( sub_nvi )
        if sub_nvi > nvi
            return []
        if _children[ sub_nvi ].size == 0
            if sub_nvi
                for num_child in 0 .. pe.nb_children( sub_nvi )
                    ns := new SymbolicElement[ pe.type_child( sub_nvi, num_child ) ]( name_elem )
                    _children[ sub_nvi ].push_back( ns )
            else
                _children[ 0 ] = [ this ]
        return _children[ sub_nvi ]
        
    #
    def std_pos_symbol_function( num_node, d )
        letters := "xyztuvw"
        return symbol( "$name_elem.node($num_node)->pos[$d]", "P_{$num_node}^{$(letters[d])}" )
        
    #
    def init( name_elem = "elem", pos_symbol_function = std_pos_symbol_function )
        init_using_default_values( self )
        self.name_elem = name_elem
        for num_node in 0 .. nb_nodes
            for d in 0 .. dim
                pos_nodes[num_node][d] = pos_symbol_function( num_node, d )
        #
        var_inter.init( x => symbol("var_inter[$x]",greek_letter(6+x)) )
        
    def interpolation( val_on_nodes ) return pe.interpolation( var_inter, val_on_nodes )
    def get_pos                       return pe.interpolation( var_inter, pos_nodes )
    def get_normal                    return pe.normal( var_inter, pos_nodes )
    def get_measure                   return pe.measure( var_inter, pos_nodes )
    def get_center_of_var_inter       return pe.center_of_var_inter # Ex : Bar -> [1/2]; Triangle -> [1/3 1/3]; ...
    def get_points                    return TE::points # Ex : Bar -> [1/2]; Triangle -> [1/3 1/3]; ...
    def val_nodes_from_lower_degre(l) return TE::val_nodes_from_lower_degre(l)
    
    def get_jac_mat
        if assume_const_jac
            return pe.jac_mat( Vec[Op,nvi](pe.center_of_var_inter), pos_nodes )
        return pe.jac_mat( var_inter, pos_nodes )
        
    def get_jac
        if assume_const_jac
            return pe.jac( Vec[Op,nvi](pe.center_of_var_inter), pos_nodes )
        return pe.jac( var_inter, pos_nodes )
        
    def get_inv_jac_mat
        if assume_const_jac
            return pe.inv_jac_mat( Vec[Op,nvi](pe.center_of_var_inter), pos_nodes )
        return pe.inv_jac_mat( var_inter, pos_nodes )
    
    #
    def get_order_interpolation
        res := Vec[ Int32, nvi ]( 0 )
        i := interpolation( Vec[ Op, nb_nodes ]( x => symbol("toto") ) )
        for num_vi in 0 .. nvi
            tmp := -1
            i_d := i
            while not assumed( i_d == 0 )
                i_d = i_d.diff( var_inter[ num_vi ] )
                tmp++
            res[ num_vi ] = tmp
        return res
    
    # 
    def dot_prod_( p0, p1 )
        return integration( p0 * p1, mul_by_jac = false )
    
    #
    def pol_inde_( lst_pol )
        si := lst_pol.size
        m := Mat[ Rationnal, Sym[ si ] ]()
        for ind, val in m
            val = dot_prod_( lst_pol[ ind[0] ], lst_pol[ ind[1] ] ).value()
        return m.det
    
    #
    def shape_functions_der( variable, sym )
        res := Vec[ Op ]()
        for s in sym
            shape_function := variable.diff( s )
            for vi in var_inter
                d := shape_function.diff( vi )
                if assumed( d == 0 ) == false and pol_inde_( res +++ [ d ] )
                    ds := d.subs( var_inter, var_inter * 0 )
                    if not assumed( d == 0 )
                        d /= ds
                    res.push_back( d )
        return res
    
    # integration
    def integration( expr, mul_by_jac = true, order_diff = 5 )
        res := scalar_conversion( Op, expr )
        if mul_by_jac
            res *= get_jac()
        interval_var_inter := pe.interval_var_inter( var_inter ) 
        for i in ( 0 .. nvi ).reversed
            res = integration( res, var_inter[i], interval_var_inter[i][0], interval_var_inter[i][1], order_diff )
        return res

    # numerical integration
    def bestial_num_integration( expr, mul_by_jac = true, div_ = 25 )
        res   := Op( 0 )
        expr_ := expr
        if mul_by_jac
            expr_ *= get_jac()
        for p in rectilinear( 0..div_+1, nvi )
            v := p / div_
            if var_inter_is_inside( v )
                res += expr_.subs( var_inter, v )
        return res / div_ ^ nvi
        
    # mean
    def mean( expr )
        return integration( expr, false ) / integration( Op( 1 ), false )
    
    # helper function -> give a new "field" based on "canonical" interpolation
    def new_variable( name, nb_dim=[], sym = Vec[Op](), interpolation_type = "nodal", symm = false ) when interpolation_type == "nodal"
        if nb_dim.size == 0
            vec := Vec[ Op, nb_nodes ]()
            for i in 0 .. vec.size
                s := Op()
                if name.type != String
                    s = name( i )
                else
                    s = symbol("$name_elem.node($i)->$name") # $name_elem.ind[$i].index
                sym.push_back( s )
                vec[i] = s
            return pe.interpolation( var_inter, vec )
        if nb_dim.size == 1
            d := nb_dim[0]
            vec := Vec[ Vec[Op,d], nb_nodes ]()
            for i in 0 .. nb_nodes
                for j in 0 .. d
                    s := Op()
                    s = symbol("$name_elem.node($i)->$name[$j]","$name^{N$i}_{$j}") # $name_elem.ind[$i].index
                    sym.push_back( s )
                    vec[i][j] = s
            return Vec[Op,d]( pe.interpolation( var_inter, vec ) )
        if nb_dim.size == 2
            TR := [ Mat[Op,Gen[nb_dim[0],nb_dim[1]]], Mat[Op,Sym[nb_dim[0]]] ][ symm ]
            mat := Vec[ TR, nb_nodes ]()
            for i in 0 .. nb_nodes
                for j in 0 .. nb_dim[0]
                    for k in 0 .. nb_dim[1]
                        if symm and k > j
                            continue
                        s := Op()
                        s = symbol("$name_elem.node($i)->$name($j,$k)","$name^{N$i}_{$j,$k}") # $name_elem.ind[$i].index
                        sym.push_back( s )
                        mat[i][j,k] = s
                if symm
                    for j in 0 .. nb_dim[0]
                        for k in j+1 .. nb_dim[1]
                            mat[i][j,k] = mat[i][k,j]
            return TR( pe.interpolation( var_inter, mat ) )
        assert( 0, "TODO" )
    
    # helper function -> give a new "field" based on "canonical" interpolation
    def new_variable( name, interpolation_type, nb_dim=[], sym = Vec[Op](), symm = false ) when interpolation_type in [ "global", "elementary" ]
        bn := [ "elem", "f" ][ interpolation_type == "global" ]
        if nb_dim.size == 0
            s := symbol("$bn.$name","$name")
            sym.push_back( s )
            return s
        if nb_dim.size == 1
            d := nb_dim[0]
            res := Vec[ Op, d ]()
            for j in 0 .. d
                s := symbol("$bn.$name[$j]","$name_{$j}")
                sym.push_back( s )
                res[j] = s
            return res
        if nb_dim.size == 2
            TR := [ Mat[Op,Gen[nb_dim[0],nb_dim[1]]], Mat[Op,Sym[nb_dim[0]]] ][ symm ]
            mat := TR()
            for j in 0 .. nb_dim[0]
                for k in 0 .. nb_dim[1]
                    if symm and k > j
                        continue
                    s := symbol("$bn.$name($j,$k)","$name_{$j,$k}")
                    sym.push_back( s )
                    mat[j,k] = s
            return mat
        assert( 0, "TODO" )
        
    # helper function -> give a new "field" based on "canonical" interpolation
    def new_variable( interpolation_type, symbol_function, sym = Vec[Op]() ) when interpolation_type.ends_by( "_minus_1" )
        wanted_interpolation := interpolation_type[ 0 .. interpolation_type.size - "_minus_1".size ]
        sp := Vec[ Op ]()
        tmp_interp := new_variable( "_tmp", interpolation_type = wanted_interpolation, sym = sp )
        base := shape_functions_der( tmp_interp, sp )
        #
        res := Op( 0 )
        for b, c in base, 0...
            s := symbol_function( c )
            sym.push_back( s )
            res += b * s
        return res
        
    #
    def make_interpolation( res, interpolation_type, met_name, tex_name ) when interpolation_type == "nodal"
        val_on_nodes := Vec[ type_of( res.val ), nb_nodes ]()
        for num_node in 0 .. nb_nodes
            for ind, val in indices_and_values_of( val_on_nodes[ num_node ] )
                if ind.size
                    j_ind := join( ind, "," )
                    val = symbol( "$met_name[$num_node]($j_ind)", "$(tex_name)_{$j_ind}^{$num_node}" )
                else
                    val = symbol( "$met_name[$num_node]", "$(tex_name)^{$num_node}" )
                res.sym.push_back( val )
        # interpolation
        res.val = interpolation( val_on_nodes )
        
    #
    virtual def grad( tens )
        assert( dim == nvi, "TODO : grad with nb_var_inter != dim ( $nvi != $dim )" )
        #
        inv_jac_  := get_inv_jac_mat()
        res := Tensor[ Op, stat_vec(tens.sizes +++ [ dim ]) ]()
        for ind, val in indices_and_values_of( tens )
            dvi := Vec[ Op, nvi ]( function = val.diff( var_inter[_0] ) )
            tmp := inv_jac_ * dvi # diff / ( X_0, X_1, X_2 ) in jac base
            for d in 0 .. dim
                res[ ind +++ [d] ] = tmp[ d ]
        return res

    #
    virtual def grad_sym( tens ) when tens.tensor_order == 1
        assert( tens.sizes.size==1, "grad_sym works only with tensor_order==1 as input." )
        tmp := self.grad( tens )
        res := Mat[ Op, Sym[Int32(tens.sizes[0])] ]()
        for ind, val in res
            val = ( tmp[ ind[0], ind[1] ] + tmp[ ind[1], ind[0] ] ) / 2
        return res

    #
    virtual def div( tens ) when tens.tensor_order == 1
        return sum( grad( tens ).diag )
    
    #
    virtual def var_inter_for_pos( p, nb_iterations = 1 )
        d := p - pos
        n := dot( d, d )
        return Vec[ Op ](
            newton_raphson_minimize_iteration_rec( n, var_inter, nb_iterations, old_values = get_center_of_var_inter() )
        )

    #
    virtual def point_is_inside( p, nb_iterations = 1, tolerance = 0 )
        vi := var_inter_for_pos( p, nb_iterations )
        return var_inter_is_inside( vi, tolerance )
        
    #
    virtual def var_inter_is_inside( vi, tolerance = 0 )
        if TE::has_a_var_inter_is_inside_method
            return TE::var_inter_is_inside( vi, tolerance )
        # -> generic case (not optimized)
        interval_var_inter := pe.interval_var_inter( vi ) 
        res := Op( 1 )
        for interval, var_inter in interval_var_inter, vi
            res *= heaviside( tolerance + var_inter - interval[0] )
            res *= heaviside( tolerance + interval[1] - var_inter )
        return res
        
    #
    virtual def extrusion_with_normals( normals, alpha )
        return pos + alpha * interpolation( normals )
        
    # 
    virtual def var_inter_and_alpha_with_normals( normals, point, nb_iterations = 1 )
        alpha := symbol( "alpha" )
        proj := extrusion_with_normals( normals, alpha )
        d := point - proj
        return newton_raphson_minimize_iteration_rec( dot(d,d), var_inter +++ [ alpha ], nb_iterations, old_values = get_center_of_var_inter() +++ [ 0 ] )
    
    #
    virtual def projection_with_normals( normals, point, nb_iterations = 1 )
        vi := var_inter_with_normals( normals, point, nb_iterations )
        return extrusion_with_normals( normals, 0 ).subs( var_inter, vi[ 0 .. var_inter.size ] )
    
    #
    virtual def get_shape_functions
        res := Vec[ Op, nb_nodes ]()
        for i in 0 .. nb_nodes
            val_on_nodes := Vec[ Op, nb_nodes ]( function = _0 == i )
            res[ i ] = interpolation( val_on_nodes )
        return res
        
        
        