import "ParametricElement.met"

#~
~#
class SymbolicElement[ TE, dim = Int32( TE::points[0].size ), lmtpp = true ]
    static const pe       := ParametricElement[ TE, dim ]()
    static const nb_nodes := pe.nb_nodes
    static const nvi      := pe.nvi # nb interpolation variables
    
    pos_nodes := Vec[ Vec[ Op, dim ], nb_nodes ]()
    var_inter := Vec[ Op, nvi ]()
    name_elem := ""
    
    #
    def std_pos_symbol_function( num_node, d )
        letters := "xyztuvw"
        if lmtpp
            return symbol( "$name_elem.node($num_node)->pos[$d]", "P_{$num_node}^{$(letters[d])}" )
        return symbol( "pos[IND($num_node)][$d]", "P_{$num_node}^{$(letters[d])}" )
        
    #
    def init( name_elem = "elem", pos_symbol_function = std_pos_symbol_function )
        init_using_default_values( self )
        self.name_elem = name_elem
        for num_node in 0 .. nb_nodes
            for d in 0 .. dim
                pos_nodes[num_node][d] = pos_symbol_function( num_node, d )
        #
        var_inter.init( x => symbol("var_inter[$x]",greek_letter(6+x)) )
        
    def interpolation( val_on_nodes ) return pe.interpolation( var_inter, val_on_nodes )
    def get_pos                       return pe.interpolation( var_inter, pos_nodes )
    def get_jac_mat                   return pe.jac_mat( var_inter, pos_nodes )
    def get_jac                       return pe.jac( var_inter, pos_nodes )
    def get_normal                    return pe.normal( var_inter, pos_nodes )
    def get_measure                   return pe.measure( var_inter, pos_nodes )
    def get_inv_jac_mat               return pe.inv_jac_mat( var_inter, pos_nodes )
    def get_center_of_var_inter       return pe.center_of_var_inter # Ex : Bar -> [1/2]; Triangle -> [1/3 1/3]; ...
    
    #
    def get_order_interpolation
        res := Vec[ Int32, nvi ]( 0 )
        i := interpolation( Vec[ Op, nb_nodes ]( x => symbol("toto") ) )
        for num_vi in 0 .. nvi
            tmp := -1
            i_d := i
            while not assumed( i_d == 0 )
                i_d = i_d.diff( var_inter[ num_vi ] )
                tmp++
            res[ num_vi ] = tmp
        return res
    
    # 
    def dot_prod_( p0, p1 )
        return integration( p0 * p1, mul_by_jac = false )
    
    #
    def pol_inde_( lst_pol )
        si := lst_pol.size
        m := Mat[ Rationnal, Sym[ si ] ]()
        for ind, val in m
            val = dot_prod_( lst_pol[ ind[0] ], lst_pol[ ind[1] ] ).value()
        return m.det
    
    #
    def shape_functions_der( variable, sym )
        res := Vec[ Op ]()
        for s in sym
            shape_function := variable.diff( s )
            for vi in var_inter
                d := shape_function.diff( vi )
                if assumed( d == 0 ) == false and pol_inde_( res +++ [ d ] )
                    ds := d.subs( var_inter, var_inter * 0 )
                    if not assumed( d == 0 )
                        d /= ds
                    res.push_back( d )
        return res
    
    # integration
    def integration( expr, mul_by_jac = true, order_diff = 5 )
        res := scalar_conversion( Op, expr )
        if mul_by_jac
            res *= get_jac()
        interval_var_inter := pe.interval_var_inter( var_inter ) 
        for i in ( 0 .. nvi ).reversed
            res = integration( res, var_inter[i], interval_var_inter[i][0], interval_var_inter[i][1], order_diff )
        return res
    
    # mean
    def mean( expr )
        return integration( expr, false ) / integration( Op( 1 ), false )
    
    # helper function -> give a new "field" based on "canonical" interpolation
    def new_variable( name, nb_dim=[], sym = Vec[Op](), interpolation_type = "nodal" ) when interpolation_type == "nodal"
        if nb_dim.size == 0
            vec := Vec[ Op, nb_nodes ]()
            for i in 0 .. vec.size
                s := Op()
                if name.type != String
                    s = name( i )
                else
                    if lmtpp
                        s = symbol("$name_elem.node($i)->$name") # $name_elem.ind[$i].index
                    else
                        s = symbol("form.$name.val.template get_val<T>( IND($i) )","$name^{N$i}") # hum !!!
                sym.push_back( s )
                vec[i] = s
            return pe.interpolation( var_inter, vec )
        if nb_dim.size == 1
            d := nb_dim[0]
            vec := Vec[ Vec[Op,d], nb_nodes ]()
            for i in 0 .. nb_nodes
                for j in 0 .. d
                    s := Op()
                    if lmtpp
                        s = symbol("$name_elem.node($i)->$name[$j]","$name^{N$i}_{$j}") # $name_elem.ind[$i].index
                    else
                        s = symbol("form.$name.val.template get_val<V<T,$d> >( IND($i) )[$j]","$name^{N$i}_{$j}") # $name_elem.ind[$i].index
                    sym.push_back( s )
                    vec[i][j] = s
            return Vec[Op,nb_dim[0]]( pe.interpolation( var_inter, vec ) )
        assert( 0, "TODO" )
    
    # helper function -> give a new "field" based on "canonical" interpolation
    def new_variable( name, interpolation_type, nb_dim=[], sym = Vec[Op]() ) when interpolation_type == "global"
        if nb_dim.size == 0
            s := symbol("form.$name.val","$name")
            sym.push_back( s )
            return s
        if nb_dim.size == 1
            d := nb_dim[0]
            res := Vec[ Op, d ]()
            for j in 0 .. d
                s := symbol("form.$name.val[$j]","$name_{$j}")
                sym.push_back( s )
                res[j] = s
            return res
        assert( 0, "TODO" )
        
    # helper function -> give a new "field" based on "canonical" interpolation
    def new_variable( interpolation_type, symbol_function, sym = Vec[Op]() ) when interpolation_type.ends_by( "_minus_1" )
        wanted_interpolation := interpolation_type[ 0 .. interpolation_type.size - "_minus_1".size ]
        sp := Vec[ Op ]()
        tmp_interp := new_variable( "_tmp", interpolation_type = wanted_interpolation, sym = sp )
        base := shape_functions_der( tmp_interp, sp )
        #
        res := Op( 0 )
        for b, c in base, 0...
            s := symbol_function( c )
            sym.push_back( s )
            res += b * s
        return res
        
    #
    def make_interpolation( res, interpolation_type, met_name, tex_name ) when interpolation_type == "nodal"
        val_on_nodes := Vec[ type_of( res.val ), nb_nodes ]()
        for num_node in 0 .. nb_nodes
            for ind, val in indices_and_values_of( val_on_nodes[ num_node ] )
                if ind.size
                    j_ind := join( ind, "," )
                    val = symbol( "$met_name[$num_node]($j_ind)", "$(tex_name)_{$j_ind}^{$num_node}" )
                else
                    val = symbol( "$met_name[$num_node]", "$(tex_name)^{$num_node}" )
                res.sym.push_back( val )
        # interpolation
        res.val = interpolation( val_on_nodes )
        
    #
    def grad( tens )
        assert( dim == nvi, "TODO : grad with nb_var_inter != dim ( $nvi != $dim )" )
        #
        inv_jac_  := get_inv_jac_mat()
        res := Tensor[ Op, stat_vec(tens.sizes +++ [ dim ]) ]()
        for ind, val in indices_and_values_of( tens )
            dvi := Vec[ Op, nvi ]( function = val.diff( var_inter[_0] ) )
            tmp := inv_jac_ * dvi # diff / ( X_0, X_1, X_2 ) in jac base
            for d in 0 .. dim
                res[ ind +++ [d] ] = tmp[ d ]
        return res

    #
    def grad_sym( tens ) when tens.tensor_order == 1
        assert( tens.sizes.size==1, "grad_sym works only with tensor_order==1 as input." )
        tmp := self.grad( tens )
        res := Tensor[ Op, stat_vec([tens.sizes[0],tens.sizes[0]]) ]( function = x => 0 )
        for ind, val in res
            val = ( tmp[ ind[0], ind[1] ] + tmp[ ind[1], ind[0] ] ) / 2
        return res

    #
    def div( tens ) when tens.tensor_order == 1
        return sum( grad( tens ).diag )
    
    #
    def var_inter_for_pos( p, nb_iterations = 1 )
        d := p - pos
        return newton_raphson_minimize_iteration_rec( dot(d,d), var_inter, nb_iterations, old_values = get_center_of_var_inter() )

    #
    def point_is_inside( p, nb_iterations = 1, tolerance = 0 )
        vi := var_inter_for_pos( p, nb_iterations )
        if TE::has_a_var_inter_is_inside_method
            return TE::var_inter_is_inside( vi, tolerance )
        # -> generic case (not optimized)
        interval_var_inter := pe.interval_var_inter( vi ) 
        res := Op( 1 )
        for interval, var_inter in interval_var_inter, vi
            res *= heaviside( tolerance + var_inter - interval[0] )
            res *= heaviside( tolerance + interval[1] - var_inter )
        return res
        
    #
    def var_inter_is_inside( vi, tolerance )
        return TE::var_inter_is_inside( vi, tolerance )
        
    #
    def extrusion_with_normals( normals, alpha )
        return pos + alpha * interpolation( normals )
        
    # 
    def var_inter_and_alpha_with_normals( normals, point, nb_iterations = 1 )
        alpha := symbol( "alpha" )
        proj := extrusion_with_normals( normals, alpha )
        d := point - proj
        return newton_raphson_minimize_iteration_rec( dot(d,d), var_inter +++ [ alpha ], nb_iterations, old_values = get_center_of_var_inter() +++ [ 0 ] )
    
    #
    def projection_with_normals( normals, point, nb_iterations = 1 )
        vi := var_inter_with_normals( normals, point, nb_iterations )
        return extrusion_with_normals( normals, 0 ).subs( var_inter, vi[ 0 .. var_inter.size ] )
    
    