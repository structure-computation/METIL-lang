import "ParametricElement.met"
import "mechanical_tensors.met"

#~
~#
class SymbolicElementAncestor
    virtual def grad( expr )                                                          abstract
    virtual def grad_sym( expr )                                                      abstract
    virtual def div( expr )                                                           abstract
    virtual def var_inter_for_pos( p, nb_iterations = 1 )                             abstract
    virtual def point_is_inside( p, nb_iterations = 1, tolerance = 0 )                abstract
    virtual def var_inter_is_inside( vi, tolerance = 0 )                              abstract
    virtual def extrusion_with_normals( normals, alpha )                              abstract
    virtual def var_inter_and_alpha_with_normals( normals, point, nb_iterations = 1 ) abstract
    virtual def projection_with_normals( normals, point, nb_iterations = 1 )          abstract
    virtual def get_shape_functions                                                   abstract
    virtual def get_shape_functions_vertex                                            abstract
    virtual def get_name                                                              abstract
    virtual def get_nb_dim                                                            abstract
    virtual def get_nb_nodes_                                                         abstract
    virtual def children( nvi )                                                       abstract
    virtual def var_inter_for_node_nb( num_node )                                     abstract
    virtual def var_inter_                                                            abstract
    virtual def node_number_is_a_vertex( i )                                          abstract

#~
~#
class SymbolicElement[ TE, dim = Int32( TE::nvi ) ] inherits SymbolicElementAncestor
    static const pe       := ParametricElement[ TE, dim ]()
    static const nb_nodes := pe.nb_nodes
    static const nb_vertex_nodes := pe.nb_vertex_nodes
    static const nvi      := pe.nvi # nb interpolation variables
    
    pos_nodes := Vec[ Vec[ Op, dim ], nb_nodes ]()
    var_inter := Vec[ Op, nvi ]()
    name_elem := ""
    _children := Vec[ Vec[ Ptr[ SymbolicElementAncestor ] ], nvi + 1 ]()
    _alternate_pos := Vec[ Op, dim ]()
    _want_alternate_pos := false
    
    assume_const_jac := 0
    num_child        := -1 # if self is a child elem
    sub_nvi          := -1 # if self is a child elem
    tex_symbol_pos   := ""
    node_numbers_to_node_numbers_in_parent_cpp := Vec[Int32]()
    
    # interval for integration
    def get_interval_var_inter
        return pe.interval_var_inter( var_inter )
    
    #
    def destroy
        for i in 1 .. nvi + 1
            for c in _children[ i ]
                delete c
    
    #
    virtual def get_nb_nodes_
        return nb_nodes
        
    #
    virtual def var_inter_
        return var_inter
    
    virtual def get_bubble_function
        res := Op( 0 )
        for s in shape_functions
            res *= s
        res /= res.subs( var_inter, get_center_of_var_inter() ) # HUM !!!!
        return res
    
    #
    virtual def var_inter_for_node_nb( num_node )
        return TE::points[ num_node ]
    
    #
    virtual def get_name
        return String( TE )
    
    #
    virtual def get_nb_dim
        return dim
        
    # renvoie une liste de pointeurs vers éléments enfant de sub_nvi-ième génération.
    virtual def children( sub_nvi )
        if sub_nvi > nvi
            return []
        if _children[ 0 ].size == 0
            _children[ 0 ] = [ this ]
            for local_sub_nvi in 1 .. nvi + 1
                for num_child in 0 .. pe.nb_children( local_sub_nvi )
                    TC := pe.type_child( local_sub_nvi, num_child )
                    ns := new SymbolicElement[ TC, dim ](
                        name_elem, 
                        node_numbers_to_node_numbers_in_parent_cpp = node_numbers_to_node_numbers_in_parent_cpp[ pe.node_number_child( local_sub_nvi, num_child ) ]
                    )
                    ns->num_child = num_child
                    ns->sub_nvi   = local_sub_nvi
                    _children[ local_sub_nvi ].push_back( ns )
        return _children[ sub_nvi ]
        
    #
    def std_pos_symbol_function( num_node, d )
        letters := "xyztuvw"
        return symbol( "$name_elem.node($num_node)->pos[$d]", tex_symbol_pos + "_{$num_node}^{$(letters[d])}" )
        
    #
    def init( name_elem = "elem", pos_symbol_function = std_pos_symbol_function, tex_symbol_pos = "P", node_numbers_to_node_numbers_in_parent_cpp = range(nb_nodes).map( TE::corr_cpp ) )
        init_using_default_values( self )
        self.tex_symbol_pos = tex_symbol_pos
        self.name_elem = name_elem
        self.node_numbers_to_node_numbers_in_parent_cpp = node_numbers_to_node_numbers_in_parent_cpp[ 0 .. nb_nodes ]
        for num_node in 0 .. nb_nodes
            for d in 0 .. dim
                pos_nodes[num_node][d] = pos_symbol_function( node_numbers_to_node_numbers_in_parent_cpp[ num_node ], d )
        #
        var_inter.init( x => symbol("var_inter[$x]",greek_letter(6+x)) )
        
    def get_pos
        if _want_alternate_pos
            return _alternate_pos
        return pe.interpolation( var_inter, pos_nodes )
    
    def interpolation( val_on_nodes ) return pe.interpolation( var_inter, val_on_nodes )
    def interpolation_vertex( val_on_vertex_nodes ) return pe.interpolation_vertex( var_inter, val_on_vertex_nodes )
    def get_normal                    return pe.normal( var_inter, pos_nodes )
    def get_measure                   return pe.measure( var_inter, pos_nodes )
    def get_center_of_var_inter       return pe.center_of_var_inter # Ex : Bar -> [1/2]; Triangle -> [1/3 1/3]; ...
    def get_points                    return TE::points # Ex : Bar -> [1/2]; Triangle -> [1/3 1/3]; ...
    def val_nodes_from_lower_degre(l) return TE::val_nodes_from_lower_degre(l)
    
    # Ex : triangle_6.set_pos_field_as_it_was_from_lower_degree_element() will set triangle_6.pos = standard pos for a Triangle
    def set_field_as_it_was_from_lower_degree_element( field )
        tmp_e := SymbolicElement[ TE::lower_degree_element ]()
        val_nodes := Vec[ field.type ]()
        for num_node in 0 .. tmp_e.nb_nodes
            val_nodes.push_back( field.subs( var_inter, tmp_e.points[ num_node ] ) )
        field = tmp_e.interpolation( val_nodes ).subs( tmp_e.var_inter, var_inter )
        return field
    
    # Ex : triangle_6.set_pos_field_as_it_was_from_lower_degree_element() will set triangle_6.pos = standard pos for a Triangle
    def set_pos_field_as_it_was_from_lower_degree_element
        tmp_e := SymbolicElement[ TE::lower_degree_element ]()
        for num_node in 0 .. tmp_e.nb_nodes
            tmp_e.pos_nodes[ num_node ] = pos.subs( var_inter, tmp_e.points[ num_node ] )
        _alternate_pos = tmp_e.pos.subs( tmp_e.var_inter, var_inter )
        _want_alternate_pos = true
    
    def var_inter_from_child_var_inter( sub_nvi, num_child, child_var_inter )
        return pe.var_inter_from_child_var_inter( sub_nvi, num_child, child_var_inter )
        
    #~
    
    ~#
    def projection_on_child_elem( expression, child_elem )
        c := child_cast( child_elem )
        return expression.subs( var_inter, var_inter_from_child_var_inter( c->sub_nvi, c->num_child, c->var_inter ) )
    
    def get_jac_mat
        if assume_const_jac
            return pe.jac_mat( Vec[Op,nvi](pe.center_of_var_inter), pos_nodes )
        return pe.jac_mat( var_inter, pos_nodes )
        
    def get_jac
        if assume_const_jac
            return pe.jac( Vec[Op,nvi](pe.center_of_var_inter), pos_nodes )
        return pe.jac( var_inter, pos_nodes )
        
    def get_inv_jac_mat
        if assume_const_jac
            return pe.inv_jac_mat( Vec[Op,nvi](pe.center_of_var_inter), pos_nodes )
        return pe.inv_jac_mat( var_inter, pos_nodes )
    
    #
    def get_order_interpolation
        res := Vec[ Int32, nvi ]( 0 )
        i := interpolation( Vec[ Op, nb_nodes ]( x => symbol("toto") ) )
        for num_vi in 0 .. nvi
            tmp := -1
            i_d := i
            while not assumed( i_d == 0 )
                i_d = i_d.diff( var_inter[ num_vi ] )
                tmp++
            res[ num_vi ] = tmp
        return res
    
    # 
    def dot_prod_( p0, p1 )
        return integration( p0 * p1, mul_by_jac = false )
    
    #
    def pol_inde_( lst_pol )
        si := lst_pol.size
        m := Mat[ Rationnal, Sym[ si ] ]()
        for ind, val in m
            val = dot_prod_( lst_pol[ ind[0] ], lst_pol[ ind[1] ] ).value()
        return m.det
    
    #
    def shape_functions_der( variable, sym )
        res := Vec[ Op ]()
        for s in sym
            shape_function := variable.diff( s )
            for vi in var_inter
                d := shape_function.diff( vi )
                if assumed( d == 0 ) == false and pol_inde_( res +++ [ d ] )
                    ds := d.subs( var_inter, var_inter * 0 )
                    if not assumed( d == 0 )
                        d /= ds
                    res.push_back( d )
        return res
    
    # integration
    def integration( expr, mul_by_jac = true, order_diff = 7, want_interval_assumptions = true )
        res := scalar_conversion( Op, expr )
        if mul_by_jac
            res *= get_jac()
        
        # interval_var_inter := pe.interval_var_inter( var_inter ) 
        # res = integration( res, var_inter[1], interval_var_inter[1][0], interval_var_inter[1][1], order_diff ) # res.display_tex()
        # info res
        # res.display_tex()
        # tmp := res
        # res = 0
        # for i in 0..101
            # res += tmp.subs( var_inter[0], interval_var_inter[0][0] + ( interval_var_inter[0][1] - interval_var_inter[0][0] ) * i / 100 )
        # return res
        
        #
        if want_interval_assumptions
            my_var_inter := Vec[Op]()
            for v in var_inter
                my_var_inter.push_back( symbol( String( v.tex_string() ) + "^k" ) )
            #
            subs_b := Vec[Op]()
            subs_e := Vec[Op]()
            for i in 0 .. var_inter.size
                b := Op( pe.interval_var_inter( my_var_inter )[ i ][ 0 ] )
                e := Op( pe.interval_var_inter( my_var_inter )[ i ][ 1 ] )
                if b.beg_value_valid()
                    my_var_inter[i].set_beg_value( b.beg_value(), false )
                if e.end_value_valid()
                    my_var_inter[i].set_end_value( e.end_value(), false )
                subs_b.push_back( var_inter   [i] )
                subs_e.push_back( my_var_inter[i] )
            res = res.subs( subs_b, subs_e )
            #
            interval_var_inter := pe.interval_var_inter( my_var_inter ) 
            for i in ( 0 .. nvi ).reversed
                res = integration( res, my_var_inter[i], interval_var_inter[i][0], interval_var_inter[i][1], order_diff )
            return res
        # else
        interval_var_inter := pe.interval_var_inter( var_inter ) 
        for i in ( 0 .. nvi ).reversed
            res = integration( res, var_inter[i], interval_var_inter[i][0], interval_var_inter[i][1], order_diff )
        return res

    # numerical integration
    def bestial_num_integration( expr, mul_by_jac = true, div_ = 25 )
        res   := Op( 0 )
        expr_ := expr
        if mul_by_jac
            expr_ *= get_jac()
        for p in rectilinear( 0..div_+1, nvi )
            v := p / div_
            if var_inter_is_inside( v )
                res += expr_.subs( var_inter, v )
        return res / div_ ^ nvi
        
    # mean
    def mean( expr )
        return integration( expr, false ) / integration( Op( 1 ), false )
    
    # helper function -> give a new "field" based on "canonical" interpolation
    def new_variable( name, nb_dim=[], sym = Vec[Op](), interpolation_type = "nodal", symm = false ) when interpolation_type == "nodal"
        if nb_dim.size == 0
            vec := Vec[ Op, nb_nodes ]()
            for i in 0 .. vec.size
                s := Op()
                if name.type != String
                    s = name( i )
                else
                    s = symbol("$name_elem.node($(node_numbers_to_node_numbers_in_parent_cpp[i]))->$name","$name^{N$(node_numbers_to_node_numbers_in_parent_cpp[i])}") # $name_elem.ind[$i].index
                sym.push_back( s )
                vec[i] = s
            return pe.interpolation( var_inter, vec )
        if nb_dim.size == 1
            d := nb_dim[0]
            vec := Vec[ Vec[Op,d], nb_nodes ]()
            for i in 0 .. nb_nodes
                for j in 0 .. d
                    s := Op()
                    s = symbol("$name_elem.node($(node_numbers_to_node_numbers_in_parent_cpp[i]))->$name[$j]","$name^{N$(node_numbers_to_node_numbers_in_parent_cpp[i])}_{$j}") # $name_elem.ind[$i].index
                    sym.push_back( s )
                    vec[i][j] = s
            return Vec[Op,d]( pe.interpolation( var_inter, vec ) )
        if nb_dim.size == 2
            TR := [ Mat[Op,Gen[nb_dim[0],nb_dim[1]]], Mat[Op,Sym[nb_dim[0]]] ][ symm ]
            mat := Vec[ TR, nb_nodes ]()
            for i in 0 .. nb_nodes
                for j in 0 .. nb_dim[0]
                    for k in 0 .. nb_dim[1]
                        if symm and k > j
                            continue
                        s := Op()
                        s = symbol("$name_elem.node($(node_numbers_to_node_numbers_in_parent_cpp[i]))->$name($j,$k)","$name^{N$(node_numbers_to_node_numbers_in_parent_cpp[i])}_{$j,$k}") # $name_elem.ind[$i].index
                        sym.push_back( s )
                        mat[i][j,k] = s
                if symm
                    for j in 0 .. nb_dim[0]
                        for k in j+1 .. nb_dim[1]
                            mat[i][j,k] = mat[i][k,j]
            return TR( pe.interpolation( var_inter, mat ) )
        assert( 0, "TODO" )
    
     # helper function -> give a new "field" based on "canonical" interpolation
    def new_variable( name, interpolation_type, nb_dim=[], sym = Vec[Op](), symm = false ) when interpolation_type == "vertex_nodal"
        nb_vertex_nodes := 0
        for i in 0.. nb_nodes
            if node_number_is_a_vertex( i )
                nb_vertex_nodes++
        if nb_dim.size == 0
            vec := Vec[ Op, nb_vertex_nodes ]()
            l := 0
            for i in 0 .. nb_nodes
                if node_number_is_a_vertex( i )
                    s := Op()
                    if name.type != String
                        s = name( i )
                    else
                        s = symbol("$name_elem.node($(node_numbers_to_node_numbers_in_parent_cpp[i]))->$name","$name^{N$(node_numbers_to_node_numbers_in_parent_cpp[i])}") # $name_elem.ind[$i].index
                    sym.push_back( s )
                    vec[l] = s
                    l++
            return pe.interpolation_vertex( var_inter, vec )
        if nb_dim.size == 1
            d := nb_dim[0]
            vec := Vec[ Vec[Op,d], nb_vertex_nodes ]()
            l := 0
            for i in 0 .. nb_nodes
                if node_number_is_a_vertex( i )
                    for j in 0 .. d
                        s := Op()
                        s = symbol("$name_elem.node($(node_numbers_to_node_numbers_in_parent_cpp[i]))->$name[$j]","$name^{N$(node_numbers_to_node_numbers_in_parent_cpp[i])}_{$j}") # $name_elem.ind[$i].index
                        sym.push_back( s )
                        vec[l][j] = s
                    l++
            return Vec[Op,d]( pe.interpolation_vertex( var_inter, vec ) )
        if nb_dim.size == 2
            TR := [ Mat[Op,Gen[nb_dim[0],nb_dim[1]]], Mat[Op,Sym[nb_dim[0]]] ][ symm ]
            mat := Vec[ TR, nb_vertex_nodes ]()
            l := 0
            for i in 0 .. nb_nodes
                if node_number_is_a_vertex( i )
                    for j in 0 .. nb_dim[0]
                        for k in 0 .. nb_dim[1]
                            if symm and k > j
                                continue
                            s := Op()
                            s = symbol("$name_elem.node($(node_numbers_to_node_numbers_in_parent_cpp[i]))->$name($j,$k)","$name^{N$(node_numbers_to_node_numbers_in_parent_cpp[i])}_{$j,$k}") # $name_elem.ind[$i].index
                            sym.push_back( s )
                            mat[l][j,k] = s
                    if symm
                        for j in 0 .. nb_dim[0]
                            for k in j+1 .. nb_dim[1]
                                mat[l][j,k] = mat[l][k,j]
                    l++
            return TR( pe.interpolation_vertex( var_inter, mat ) )
        assert( 0, "TODO" )
    
    # helper function -> give a new "field" based on "canonical" interpolation
    def new_variable( name, interpolation_type, nb_dim=[], sym = Vec[Op](), symm = false ) when interpolation_type in [ "global", "elementary" ]
        bn := [ "elem", "f" ][ interpolation_type == "global" ]
        if nb_dim.size == 0
            s := symbol("$bn.$name","$name")
            sym.push_back( s )
            return s
        if nb_dim.size == 1
            d := nb_dim[0]
            res := Vec[ Op, d ]()
            for j in 0 .. d
                s := symbol("$bn.$name[$j]","$name_{$j}")
                sym.push_back( s )
                res[j] = s
            return res
        if nb_dim.size == 2
            TR := [ Mat[Op,Gen[nb_dim[0],nb_dim[1]]], Mat[Op,Sym[nb_dim[0]]] ][ symm ]
            mat := TR()
            for j in 0 .. nb_dim[0]
                for k in 0 .. nb_dim[1]
                    if symm and k > j
                        continue
                    s := symbol("$bn.$name($j,$k)","$name_{$j,$k}")
                    sym.push_back( s )
                    mat[j,k] = s
            return mat
        assert( 0, "TODO" )
        
    # helper function -> give a new "field" based on "canonical" interpolation
    def new_variable( interpolation_type, symbol_function, sym = Vec[Op]() ) when interpolation_type.ends_by( "_minus_1" )
        wanted_interpolation := interpolation_type[ 0 .. interpolation_type.size - "_minus_1".size ]
        sp := Vec[ Op ]()
        tmp_interp := new_variable( "_tmp", interpolation_type = wanted_interpolation, sym = sp )
        base := shape_functions_der( tmp_interp, sp )
        #
        res := Op( 0 )
        for b, c in base, 0...
            s := symbol_function( c )
            sym.push_back( s )
            res += b * s
        return res
        
    #
    def make_interpolation( res, interpolation_type, met_name, tex_name ) when interpolation_type == "nodal"
        val_on_nodes := Vec[ type_of( res.val ), nb_nodes ]()
        for num_node in 0 .. nb_nodes
            for ind, val in indices_and_values_of( val_on_nodes[ num_node ] )
                if ind.size
                    j_ind := join( ind, "," )
                    val = symbol( "$met_name[$(node_numbers_to_node_numbers_in_parent_cpp[num_node])]($j_ind)", "$(tex_name)_{$j_ind}^{$num_node}" )
                else
                    val = symbol( "$met_name[$(node_numbers_to_node_numbers_in_parent_cpp[num_node])]", "$(tex_name)^{$(node_numbers_to_node_numbers_in_parent_cpp[num_node])}" )
                res.sym.push_back( val )
        # interpolation
        res.val = interpolation( val_on_nodes )
        
    #
    virtual def grad( tens )
        assert( dim == nvi, "TODO : grad with nb_var_inter != dim ( $nvi != $dim )" )
        #
        inv_jac_  := get_inv_jac_mat()
        res := Tensor[ Op, stat_vec(tens.sizes +++ [ dim ]) ]()
        for ind, val in indices_and_values_of( tens )
            dvi := Vec[ Op, nvi ]( function = val.diff( var_inter[_0] ) )
            tmp := inv_jac_ * dvi # diff / ( X_0, X_1, X_2 ) in jac base
            for d in 0 .. dim
                res[ ind +++ [d] ] = tmp[ d ]
        if tens.sizes.size == 0
            return Vec[Op]( res.values )
        return res

    #
    virtual def grad_sym( tens ) when tens.tensor_order == 1
        assert( tens.sizes.size==1, "grad_sym works only with tensor_order==1 as input." )
        tmp := self.grad( tens )
        res := Mat[ Op, Sym[Int32(tens.sizes[0])] ]()
        for ind, val in res
            val = ( tmp[ ind[0], ind[1] ] + tmp[ ind[1], ind[0] ] ) / 2
        return res

    #
    virtual def div( tens ) when tens.tensor_order == 1
        return sum( grad( tens ).diag )
    
    #
    virtual def div( tens ) when tens.tensor_order == 2
        assert( tens.sizes[0] == tens.sizes[1], "TODO -> mettre la bonne formule" )
        res := Vec[Op,tens.sizes[0]]()
        for i in 0 .. tens.sizes[0]
            res[i] = div( tens.row( i ) )
        return res
    
    #~
        returns var_inter of self for a position p
        meaning that p is a vector of size e.dim
    ~#
    virtual def var_inter_for_pos( p, nb_iterations = 1 )
        d := p - pos
        # if nvi == dim
            # return Vec[ Op ]( newton_raphson_iteration( d, var_inter, assume_matrix_is_factorizable = true ) )
        return Vec[ Op ]( newton_raphson_minimize_iteration( dot( d, d ), var_inter, assume_matrix_is_factorizable = true ) )

    #~
        returns a symbolic function = 1 if position p is inside self
        meaning that p is a vector of size e.dim
    ~#
    virtual def point_is_inside( p, nb_iterations = 1, tolerance = 0, z_tolerance = 1e-2 )
        vi := var_inter_for_pos( p, nb_iterations )
        if nvi == dim
            return var_inter_is_inside( vi, tolerance )
        d := p - pos.subs( var_inter, vi )
        return var_inter_is_inside( vi, tolerance ) * ( dot( d, d ) < z_tolerance ^ 2 * measure ^ ( 2 / nvi ) )
        
    #
    virtual def var_inter_is_inside( vi, tolerance = 0 )
        if TE::has_a_var_inter_is_inside_method
            return TE::var_inter_is_inside( vi, tolerance )
        # -> generic case (not optimized)
        interval_var_inter := pe.interval_var_inter( vi ) 
        res := Op( 1 )
        for interval, var_inter in interval_var_inter, vi
            res *= heaviside( tolerance + var_inter - interval[0] )
            res *= heaviside( tolerance + interval[1] - var_inter )
        return res
        
    #
    virtual def extrusion_with_normals( normals, alpha )
        return pos + alpha * interpolation( normals )
        
    # 
    virtual def var_inter_and_alpha_with_normals( normals, point, nb_iterations = 1 )
        alpha := symbol( "alpha" )
        proj := extrusion_with_normals( normals, alpha )
        d := point - proj
        return newton_raphson_minimize_iteration_rec( dot(d,d), var_inter +++ [ alpha ], nb_iterations, old_values = get_center_of_var_inter() +++ [ 0 ] )
    
    #
    virtual def projection_with_normals( normals, point, nb_iterations = 1 )
        vi := var_inter_with_normals( normals, point, nb_iterations )
        return extrusion_with_normals( normals, 0 ).subs( var_inter, vi[ 0 .. var_inter.size ] )
    
    # return shape functions for nb_nodes
    virtual def get_shape_functions
        res := Vec[ Op, nb_nodes ]()
        for i in 0 .. nb_nodes
            val_on_nodes := Vec[ Op, nb_nodes ]( function = _0 == i )
            res[ i ] = interpolation( val_on_nodes )
        return res
        
    # return shape functions for nb_vertex_nodes
    virtual def get_shape_functions_vertex
        res := Vec[ Op, nb_vertex_nodes ]()
        for i in 0 .. nb_vertex_nodes
            val_on_vertex_nodes := Vec[ Op, nb_vertex_nodes ]( function = _0 == i )
            res[ i ] = interpolation_vertex( val_on_vertex_nodes )
        return res
    
    # return a function != 0 if self and e may have a common area
    def area_intersection( e, mul_by_jac = true )
        return integration( e.point_is_inside( pos ), mul_by_jac )
    
    # return true if node number $node_number is a vertex in self
    # Example : Bar 0 -- 1 -- 2 -- 3 return true false false true for respectively 0 1 2 3
    virtual def node_number_is_a_vertex( node_number )
        return TE::node_number_is_a_vertex( node_number )
        
    def corr_cpp( num_node )
        return TE::corr_cpp( num_node )
        
    def get_vertex_node_numbers_to_node_numbers_in_parent_cpp
        vertex_node_numbers_to_node_numbers_in_parent_cpp := Vec[ Int32 ]()
        for i in 0 .. nb_nodes
            if node_number_is_a_vertex( i )
                vertex_node_numbers_to_node_numbers_in_parent_cpp.push_back( node_numbers_to_node_numbers_in_parent_cpp[i] )
        return vertex_node_numbers_to_node_numbers_in_parent_cpp
        
    def get_node_numbers_to_vertex_node_numbers
        node_numbers_to_vertex_node_numbers := Vec[ Int32 ]()
        cpt_vertex_nodes := 0
        for i in 0 .. nb_nodes
            node_numbers_to_vertex_node_numbers.push_back( cpt_vertex_nodes )
            if node_number_is_a_vertex( i )
                cpt_vertex_nodes++
        return node_numbers_to_vertex_node_numbers
        
    def projection_on_base_pol( expr, p )
        base := Vec[ Op ]()
        for order in 0 .. (p+1)
            for comb in ConstantSumList( sum = order, list_size = nvi )
                base.push_back( product( var_inter ^ comb ) )
        c := Vec[ Op, base.size]( function = x => symbol("c[$x]") )
        pol := dot( c, base )
        r := integration( ( expr - pol ) ^ 2, false )
        res := dot( newton_raphson_minimize_iteration( r, c ), base )
        return res
        