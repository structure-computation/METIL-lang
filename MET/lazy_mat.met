import "lazy_vec.met"
import "lazy_mat_cholesky.met"

#~
~#
class LazyMatTinyBlock[ T, br, bc ]
    property does_not_need_destroy
    static const SDS := default_simd_size( T )
    static const needed_alignement := SDS * T.byte_size
    static const nb_data := ceil( br * bc, SDS )
    static const max_simd_col := bc - bc % SDS
    
    data := Vec[ T, nb_data ]()
    
    static def offset( r, c )
        if c < max_simd_col
            return r * max_simd_col + c
        return c * br + r
        
    def select( r, c )
        return data[ offset( r, c ) ]
    
#~
~#
class LazyMatSubBlock[ T, ST, br, bc ]
    static const TD := LazyMatTinyBlock[ T, br, bc ]
    beg_ind := Vec[ST]()
    indices := Vec[ST]()
    data    := Vec[TD]()
    
    def read_data_from_file( fi )
        # tiny_block_size
        tiny_block_size := fi.read( Int32 )
        # beg_ind
        beg_ind.resize_without_init( fi.read( Int32 ) )
        fi.read( beg_ind.begin.ptr, beg_ind.data_size_in_bytes )
        nb_data := beg_ind.back
        # indices
        indices.resize_without_init( nb_data )
        fi.read( indices.begin.ptr, indices.data_size_in_bytes )
        # data
        data.resize_without_init( nb_data )
        fi.read( data.begin.ptr, data.data_size_in_bytes )

    def select( r, c )
        cd3 := c // 3
        rd3 := r // 3
        for i in beg_ind[ rd3 ] .. beg_ind[ rd3+1 ]
            ind := indices[i]
            if ind > cd3
                return T( 0 )
            else if ind == cd3
                return data[i].select( r%3, c%3 )
        return T( 0 )

#
class LMatSubBlockBinReader inherits LazyFunc
    property has_repr
    s := Int64( 0 ) # used only for timing and data size estimation
    t := Int64( 0 )
    f := ""
    x := 0
    y := 0
    def apply( data, args )
        fi := File( f, "r" )
        fi.seek( t )
        data->init()
        data->read_data_from_file( fi )
        
    def nb_mem_rw_estimation( T, args )       return s
    def produced_data_estimation( T, args )   return s
    def repr                                  return "R[$y,$x]"


#~
    simplified Lazy matrix (1 block_size...)
~#
class LazyMat[ T, sym = false, ST = SizeType, br = 3, bc = br ]
    property is_a_LazyMat, is_lazy
    static const LO := LazyObject[ LazyMatSubBlock[ T, ST, br, bc ] ]
    static const TSubBlock := PtrWithCptUse[ LO ]
    static const tensor_order := 2
    
    sub_blocks  := Vec[ VecSparse[ TSubBlock ] ]()
    block_sizes := Vec[ Vec[ ST ], 2 ]() # [ row_sizes, col_sizes ]
    # prefered_block_sizes := ceil( 100000, tiny_block_sizes[] )
    
    # def init( nr = 0, nc = nr )
        # init_using_default_values( self )
        # if nr or nc
            # nb_row_blocks := ( nr + prefered_block_size - 1 ) // prefered_block_size
            # nb_col_blocks := ( nr + prefered_block_size - 1 ) // prefered_block_size
            # sub_blocks.resize( nb_row_blocks )
            # for s in sub_blocks
                # s.size = nb_col_blocks
            # #
            # block_sizes[0].resize( nb_row_blocks, default_value = prefered_block_size )
            # block_sizes[1].resize( nb_col_blocks, default_value = prefered_block_size )
            # block_sizes[0].back = nr - ( nb_row_blocks - 1 ) * prefered_block_size
            # block_sizes[1].back = nc - ( nb_col_blocks - 1 ) * prefered_block_size

    #
    def read_bin( file_name )
        obs := Vec[Int32,2]( [ block_sizes[0].size, block_sizes[0].size ] )
        
        f := File( file_name, "r" )
        nb := f.read( Int64 )
        ob := f.read( Int64 )
        for i in 0 .. nb - 1
            nb := f.read( Int64 )
            block_sizes[0].push_back( Int32( nb - ob ) )
            block_sizes[1].push_back( Int32( nb - ob ) )
            ob = nb
        
        sub_blocks.size = block_sizes[1].size
        for s in sub_blocks
            s.size = block_sizes[0].size
        
        for x in obs[0] .. block_sizes[0].size
            for y in obs[1] .. block_sizes[1].size
                tell_nb_beg := f.tell
                
                # nb_beg
                tiny_block_size := f.read( Int32 )
                nb_beg := f.read( Int32 )
                begs := f.read( Int32, nb_beg )
                nb_data := begs[ nb_beg-1 ]
                
                # reader
                TB := LazyMatTinyBlock[ T, br, bc ]
                si := nb_data * ( ST.byte_size + TB.byte_size_if_in_vec )
                if nb_data
                    if x <= y
                        sub_blocks[y][x] = new LO( function = new LMatSubBlockBinReader( s = si, t = tell_nb_beg, f = file_name, x = x, y = y ) )
                
                # end of data
                # f.seek( f.tell + si )
                f.seek( tell_nb_beg )
                
                #
                begs.free()
        

    
    