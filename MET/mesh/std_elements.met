import "reference_element.met"
import "element_interpolation.met"
import "symbolic_element.met"

#~
    Ancestor for parametric elements like Quad, Triangle, ...
~#
class ParametricElement[ T, dim, ST, RefElem, nb_nodes ]
    static const Tnode := Node[T,dim,ST]
    static const vtk_type := -1 # -> -1 means no vtk representation
    static const nb_var_inter := RefElem::nb_var_inter
    
    nodes := Vec[ Ptr[Tnode], nb_nodes ]()
    ref_elem := RefElem()

    def get_node_numbers
        return Vec[ ST, nb_nodes ]( nodes.map( _0->number ) )
    
    def interval_var_inter( vi ) 
        return ref_elem.interval_var_inter( vi )

    def point_is_inside( p ) pertinence 0.5
        assert( 0, "TODO" )
        
    def var_inter_is_inside( vi )
        i := interval_var_inter( vi )
        r := heaviside( vi[0] - i[0][0] ) * heaviside( i[0][1] - vi[0] )
        for ni in 1 .. i.size
            r *= heaviside( vi[ni] - i[ni][0] ) * heaviside( i[ni][1] - vi[ni] )
        return r

#~
   0 - 1
~#
class Bar[ T=Float64, dim=1, ST=SizeType ] inherits ParametricElement[ T, dim, ST, ReferenceElementBar, nb_nodes = 2 ]
    static const vtk_type := 3
    static const normal_flip_permutation := [ 1 0 ]
    static const possible_permutations := []
    static const pos_node := [ [0], [1] ]
    
    def interpolation( vi, v )
        return ( 1 - vi[0] ) * v[0] + vi[0] * v[1]
    
    def point_is_inside( p )
        P0P1 := nodes[1]->pos - nodes[0]->pos
        d  := dot( p - nodes[0]->pos, P0P1 )
        dl := dot(      P0P1        , P0P1 )
        return ( d >= 0 ) * ( d <= dl )

#~
   0 - 2 - 1
~#
class Bar_3[ T=Float64, dim=1, ST=SizeType ] inherits ParametricElement[ T, dim, ST, ReferenceElementBar, nb_nodes = 3 ]
    static const vtk_type := 21
    static const normal_flip_permutation := [ 1 0 2 ]
    static const possible_permutations := []
    static const pos_node := [ [0], [1], [0.5] ]
    
    def interpolation( vi, v )
        return (1-vi[0]) * (1-2*vi[0]) * v[0] + vi[0] * (2*vi[0]-1) * v[1] + 4 * (1-vi[0]) * vi[0] * v[2]

#~
   3 - 2
   |   |
   0 - 1
~#
class Quad[ T=Float64, dim=2, ST=SizeType ] inherits ParametricElement[ T, dim, ST, ReferenceElementQuad, nb_nodes = 4 ]
    static const vtk_type := 9
    static const normal_flip_permutation := [ 0 3 2 1 ]
    static const possible_permutations := [ [ 1 2 3 0 ], [ 2 3 0 1 ], [ 3 0 1 2 ] ]
        
    def interpolation( vi, v )
        return (1-vi[0]) * (1-vi[1]) * v[0] + 
                 vi[0]   * (1-vi[1]) * v[1] +
                 vi[0]   *   vi[1]   * v[2] +
               (1-vi[0]) *   vi[1]   * v[3]
    
    def children( vi )
        return [
            ( Bar, [0, 1], [ vi[0]  , 0       ] ),
            ( Bar, [1, 2], [ 1      , vi[0]   ] ),
            ( Bar, [2, 3], [ 1-vi[0], 1       ] ),
            ( Bar, [3, 0], [ 0      , 1-vi[0] ] )
        ]

#~
    2
    |\
    | \
    0--1
~#
class Triangle[ T=Float64, dim=2, ST=SizeType ] inherits ParametricElement[ T, dim, ST, ReferenceElementTriangle, nb_nodes = 3 ]
    static const vtk_type := 5
    static const normal_flip_permutation := [ 0 2 1 ]
    static const possible_permutations := [ [ 1 2 0 ], [ 2 0 1 ] ]
    static const pos_node := [ [0,0], [1,0], [0,1] ]
    
    def interpolation( vi, v )
        return ( 1 - vi[0] - vi[1] ) * v[0] + vi[0] * v[1] + vi[1] * v[2]

#~
         3
        /|\
       / | \
      /  |  \
     /  /2\  \
    / /     \ \
   0/---------\1
~#
class Tetra[ T=Float64, dim=2, ST=SizeType ] inherits ParametricElement[ T, dim, ST, ReferenceElementTetra, nb_nodes = 4 ]
    static const vtk_type := 10
    static const normal_flip_permutation := [ 0 3 2 1 ]
    static const possible_permutations := [
        [ 0 2 3 1 ], [ 0 3 1 2 ], [ 1 0 3 2 ], [ 1 2 0 3 ],
        [ 1 3 2 0 ], [ 2 0 1 3 ], [ 2 1 3 0 ], [ 2 3 0 1 ],
        [ 3 0 2 1 ], [ 3 1 0 2 ], [ 3 2 1 0 ]
    ]
    static const pos_node := [ [0,0,0], [1,0,0], [0,1,0], [0,0,1] ]
    
    def interpolation( vi, v )
        return ( 1 - vi[0] - vi[1] - vi[2] ) * v[0] + vi[0] * v[1] + vi[1] * v[2] + vi[2] * v[3]

