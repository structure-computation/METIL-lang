
#~
    TE -> type d'element (Bar, Quad, ...)
~#
class SymbolicElement[ TE, dim = TE::dim ]
    static const TTE := TE[ Op, dim ]
    static const nb_nodes := TTE::nb_nodes
    static const nb_var_inter := TTE::nb_var_inter
    static const ST := TTE::ST
    
    e ~= TTE
    node_list := Vec[ Node[ Op, dim, ST ], nb_nodes ]()
    var_inter := Vec[ Op, nb_var_inter ]()
    name_elem := ""
    
    def init( name_elem_in_cpp = "e" ) when name_elem_in_cpp.type==String
        e.init(); name_elem.init( name_elem_in_cpp )
        for num_node in 0 .. nb_nodes
            for d in 0 .. dim
                node_list[ num_node ].pos[ d ].init( symbol( "$name_elem.node($num_node)->pos[$d]", "P^{N$num_node}_{$d}" ) )
            node_list[ num_node ].number = num_node
            #
            e.nodes[ num_node ] = &node_list[ num_node ]
        #
        var_inter.init( x => symbol("var_inter[$x]",greek_letter(6+x)) )
        
    def get_pos
        return Vec[ Op, dim ]( e.interpolation( var_inter, node_list.map( _0.pos ) ) )
        
    def get_jac
        res := Mat[ Op, Gen[nb_var_inter,nb_var_inter] ]()
        P := pos
        if nb_var_inter==dim
            for v in 0 .. nb_var_inter
                for d in 0 .. dim
                    res[v,d] = P[d].diff(var_inter[v])
        else # Ex: Bar in 2D, Triangle in 3D...
            jb := get_jac_base()
            for i in 0 .. nb_var_inter
                for j in 0 .. nb_var_inter
                    for d in 0 .. dim
                        res[j,i] += P[d].diff(var_inter[j]) * jb[i][d]
        return res
        
    def get_jac_base # base of jacobian matrix (useful when nb_var_inter != dim )
        res := Vec[ Vec[Op,dim], nb_var_inter ]()
        if nb_var_inter==dim
            for j in 0 .. nb_var_inter
                for i in 0 .. dim
                    res[i][j] = ( i==j )
        else # Ex: Bar in 2D
            P := get_pos()
            for ni in 0 .. nb_var_inter
                for d in 0 .. dim
                    res[ni][d] = P[d].diff( var_inter[ni] ) 
                # orthogonalization
                for nni in 0 .. ni
                    res[nni] -= res[ni] * dot( res[ni], res[nni] )
                res[ni] /= norm_2( res[ni] )
        return res
        
    def new_variable( name, nb_dim=[] ) pertinence 3
        if nb_dim.size == 0
            vec := Vec[ Op, nb_nodes ]()
            for i in 0 .. vec.size
                vec[i] = symbol("$name_elem.node($i)->$name")
            return e.interpolation( var_inter, vec )
        if nb_dim.size == 1
            d := nb_dim[0]
            vec := Vec[ Vec[Op,d], nb_nodes ]()
            for i in 0 .. nb_nodes
                for j in 0 .. d
                    vec[i][j] = symbol("$name_elem.node($i)->$name[$j]","$name^{N$i}_{$j}")
            return Vec[Op,nb_dim[0]]( e.interpolation( var_inter, vec ) )
    
    def get_nodes
        return e.nodes
                
    def integration( expr, mul_by_jac = true )
        res := scalar_conversion( Op, expr )
        if mul_by_jac
            res *= jac.det
        interval_var_inter := e.interval_var_inter( var_inter ) 
        for i in ( 0 .. nb_var_inter ).reversed
            res = integration( res, var_inter[i], interval_var_inter[i][0], interval_var_inter[i][1] )
        return res
                
    def get_measure
        return integration( Op(1) )
        
    # Ex : Bar -> [1/2]; Triangle -> [1/3 1/3]; ...
    def get_center_of_var_inter
        res := Vec[ Op, nb_var_inter ]()
        return self.integration( var_inter, false ) / self.integration( 1, false )
        
    def point_is_inside( p )
        return e.point_is_inside( p )
    
    def var_inter_for_pos( p, nb_iterations )
        d := p - pos
        return newton_raphson_minimize_iteration_rec( dot(d,d), var_inter, nb_iterations, old_values = get_center_of_var_inter() )
        
    def var_inter_is_inside( vi ) 
        return heaviside( vi[0] ) * heaviside( 1 - vi[0] )

    def var_inter_on_node_nb( n )
        return e.pos_node[ n ]

    def grad( tens )
        assert( dim == nb_var_inter, "TODO : grad with nb_var_inter != dim ( $nb_var_inter != $dim )" )
        #
        inv_jac_  := inv_tiny( get_jac() )
        jac_base_ := get_jac_base()
        res := Tensor[ Op, tens.sizes +++ [ dim ] ]()
        for ind, val in indices_and_values_of( tens )
            dvi := Vec[ Op, nb_var_inter ]( function = val.diff( var_inter[_0] ) )
            tmp := inv_jac_ * dvi # diff / ( X_0, X_1, X_2 ) in jac base
            for n in 0 .. nb_var_inter
                for d in 0 .. dim
                    res[ ind +++ [d] ] += jac_base_[n][d] * tmp[ n ]
        return res
        
    def grad_sym( tens ) when tens.tensor_order == 1
        tmp := self.grad( tens )
        res := Tensor[ Op, [tens.size,tens.size] ]( x => 0 )
        for ind, val in res
            val = ( tmp[ ind[0], ind[1] ] + tmp[ ind[1], ind[0] ] ) / 2
        return res
        
        