import "mesh.met"

#~
~#
class GenericParametricElementGenerator[ RefElem, pos_nodes ]
    static const nb_nodes := pos_nodes.size
    static const nb_var_inter := RefElem::nb_var_inter
    
    ref_elem  := RefElem()
    var_inter := Vec[ Op, nb_var_inter ]()
    val       := Vec[ Op, nb_nodes      ]()
    base      := Vec[ Op ]()
    shape_functions := Vec[ Op, nb_nodes ]()
    
    def init
        ref_elem .init()
        var_inter.init( function = symbol( "var_inter[$_0]", greek_letter(6+_0) ) )
        val      .init( function = symbol( "val[$_0]"      , "N_{$_0}"          ) )
        base     .init()
        shape_functions.init()
        #
        for order in 0...
            for comb in ConstantSumList( sum = order, list_size = nb_var_inter )
                base.push_back( product( var_inter ^ comb ) )
            if base.size >= nb_nodes
                if construct_shape_function_using_current_base()
                    break
                
    def construct_shape_function_using_current_base
        bs := base.size
        shape_coeffs := Vec[ Vec[Op,bs], nb_nodes ]()
        shape_coeffs_flat := Vec[Op]( reservation = base.size * nb_nodes ) # TODO -> generic flatten function
        for n in 0 .. nb_nodes
            shape_coeffs[n].init( function = symbol("coeff[$n,$_0]","C_{$n,$_0}") )
            shape_coeffs_flat.append( shape_coeffs[n] )
            shape_functions[n] = dot( shape_coeffs[n], base )
            
        # objective function
        objective := Op()
        # 1 or 0 in pos_node
        for n in 0 .. nb_nodes
            for m in 0 .. nb_nodes
                objective += ( shape_functions[n].subs( var_inter, pos_nodes[m] ) - (n==m) ) ^ 2
        # independance on subparts of skin from exterior points
        child_var_inter := Vec[ Op, nb_var_inter - 1 ]( function = symbol("child_var_inter[$_0]",greek_letter(6+_0)+"^{C}") )
        for child in ref_elem.children( child_var_inter )
            for n in 0 .. nb_nodes
                if not ref_elem.point_is_in_children( child_var_inter, child, pos_nodes[n] )
                    err := shape_functions[n].subs( var_inter, child.var_inter )
                    objective += child.elem.integration( err ^ 2, child_var_inter )
        # partition of unity
        objective += ref_elem.integration( ( sum( shape_functions ) - 1 ) ^ 2, var_inter )
                
        # solve
        sol := newton_raphson_minimize_iteration( objective, shape_coeffs_flat )
        #
        for n in 0 .. nb_nodes
            shape_functions[n] = shape_functions[n].subs( shape_coeffs[n], sol[ n*base.size .. (n+1)*base.size ] )
            # info shape_functions[n].subs( var_inter[0], 0 )
            # for m in 0 .. nb_nodes info shape_functions[n].subs( var_inter, pos_nodes[m] )
        return assumed( objective.subs( shape_coeffs_flat, sol ) < 1e-6 )
   
    def generate_if_necessary_and_return_filename
        res := ".generated/generated_element.met"
        f := File( res, "w" )
        f <<< "static const normal_flip_permutation := []"
        f <<< "static const possible_permutations := []"
        f <<< "def interpolation( var_inter, val )"
        f <<< "    return $( dot( shape_functions, val ) )"
        return res


#~
~#
class GenericParametricElement[ RefElem, pos_nodes, T=Float64, dim=1, ST=SizeType ] inherits ParametricElement[ T, dim, ST, RefElem, nb_nodes = pos_nodes.size ]
    static generator := GenericParametricElementGenerator[ RefElem, pos_nodes ]()
    import generator.generate_if_necessary_and_return_filename()

# for nb_var in 2 .. 3
    # for n in 1 .. 7
        # a := Vec[ Vec[ Op, n ], nb_var ]()
        # b := Vec[ Vec[ Op, n ], nb_var ]() #  function = symbol("P1.coeff[$_0]") 
        # for i in 0 .. nb_var
            # for j in 0 .. n
                 # a[i][j] = symbol( "P0.coeffs[$i][$j]" )
                 # b[i][j] = symbol( "P1.coeffs[$i][$j]" )
        # t := Vec[ Op, nb_var ]( function = symbol("t[$_0]") )
        # A := Op(0)
        # for i in rectilinear( 0 .. n, nb_var )
            # A += dot( a[], t ^ i )
            
        # toto := dot( a, t ^ (0..a.size) ) / dot( b, t ^ (0..a.size) )
        # cw := CodeWriter()
        # for i in 0 .. n
            # cw.add( "res[$i]", toto.subs( t, 0 ) / factorial( i ) )
            # info toto.subs( t, 0 ) / factorial( i )
            # toto = toto.diff( t )
        # print "Pol<T,$(n-1)> div( Pol<T,$(n-1)> &P0, Pol<T,$(n-1)> &P1 ) {"
        # print "    Pol<T,$(n-1)> res;"
        # print cw.to_string()
        # print "    return res;"
        # print "}"
# base := Vec[Op]()
# nb_var := 2
# var_inter := Vec[ Op, nb_var ]( function = symbol( "var_inter[$_0]", greek_letter(6+_0) ) )
# for order in 0..4
    # for comb in ConstantSumList( sum = order, list_size = nb_var )
        # base.push_back( product( var_inter ^ comb ) )
    # # info base
# # base.display_tex()

# a := Vec[ Op, base.size ]( function = symbol("P0.coeff[$_0]","a_{$_0}")  )
# b := Vec[ Op, base.size ]( function = symbol("P1.coeff[$_0]","b_{$_0}")  )
# A := dot( a, base )
# B := dot( b, base )
# # A.display_tex()
# toto := A / B
# cw := CodeWriter()
# cpt := 0
# for order in 0..4
    # for comb in ConstantSumList( sum = order, list_size = nb_var )
        # info comb
        # r := toto
        # for c, num_var_inter in comb, 0...
            # for n in 0 .. c
                # r = r.diff( var_inter[num_var_inter] )
            # r /= factorial( c )
        # cw.add( "res[$(cpt++)]", r.subs( var_inter, vec_cst(0,100) ) )
    # # info toto.subs( t, 0 ) / factorial( i )
# n := 64
# print "Pol<T,$(n-1)> div( Pol<T,$(n-1)> &P0, Pol<T,$(n-1)> &P1 ) {"
# print "    Pol<T,$(n-1)> res;"
# print cw.to_string()
# print "    return res;"
# print "}"
# NE := GenericParametricElement[ ReferenceElementBar, [ [0], [1/3], [2/3], [1] ] ]
# f := File("serendip_elements","w")
# f := ref stdout
# # gps := VarArgs()
# for nb_subdivisions in 0 .. 2
    # points := Vec[ Vec[Rationnal,2] ]( [ [0,0], [1,0], [0,1] ] )
    # # skin subdivide
    # for child in 0 .. 3
        # for n in 0 .. nb_subdivisions
            # c := ( n + 1 ) / ( nb_subdivisions + 1 )
            # r := Vec[Rationnal,2]( points[child] * ( 1 - c ) + points[ (child+1)%3 ] * c )
            # points.push_back( r )
    # # find intersections
    # for s in 1 .. nb_subdivisions
        # for t in 1 .. nb_subdivisions - s + 1
            # points.push_back( [ t / (nb_subdivisions+1), s / (nb_subdivisions+1) ] )
    # # generate
    # # print points
    # # gp := popen( "gnuplot", "w" )
    # # gp <<< "plot '-'"
    # # for p in points
        # # gp << Float64(p[0]) << " " <<< Float64(p[1])
    # # gp <<< "e"
    # # gp.flush()
    # # gps.push_unnamed(gp)
    # # for i in 0 .. 1e9 pass
    # f <<< points
    # pe := GenericParametricElementGenerator[ ReferenceElementTriangle, points ]()
    # # f <<< "shape functions"
    # cw := CodeWriter( "double" )
    # cw.add( "ma_sortie", pe.shape_functions, reassign )
    # f <<< "void toto( double *ma_sortie, double *var_inter ) {\n$(cw.to_string())\n}"
    
    # f <<< "gradient"
    # for sf in pe.shape_functions
        # f << "\t" <<< join( pe.var_inter.map( sf.diff(_0) ), ",\t" )
    # f.flush()
