# ------------------------------------------------------------------------------------------------
#~
    Experimental
~#
class LazyCriticalPathBand
    #
    class LObData
        bottom_level             := Float64( 0 )
        higher_level             := Float64( 0 )
        best_timing              := Float64( -1 )
        produced_data_estimation := Float64( -1 )
        strip_nb                 := -1
        nb_times_used            := 0
        lop                      := MultiPtr() # ptr on lazy object self is attached
        registered_in_instr      := false # already in instructions of a particular cpu
        serialized_on            := Ptr[ LazyComputerInfo::ExternalMemory ]( NULL ) # in hard disk
        next_in_strip            := UntypedPtr( NULL ) # PL
        prev_in_strip            := UntypedPtr( NULL ) # PL
        
        def in_front
            return all( lop->args.map( _0->op_id != lop->op_id ) ) and not prev_in_strip
        
        def needed_communication
            res := Float64( 0 )
            PL := Ptr[LazyCriticalPathBand::LObData]
            for a in lop->args
                ad := PL(a->sch_data)
                if ad->strip_nb == strip_nb
                    res += ad->produced_data_estimation
            return res
    
    #
    class CpuData
        nb_op := Float64( 0 )
        def free_exec_sim
            nb_op = 0
    #
    class NetData
        nb_rw := Float64( 0 )
        def free_exec_sim
            nb_rw = 0
    #
    class MemData
        nb_rw := Float64( 0 )
        used  := Float64( 0 )
        def free_exec_sim
            nb_rw = 0
            used = 0
    #
    class Strip
        first_op   := Ptr[LazyCriticalPathBand::LObData]( NULL )
        last_op    := Ptr[LazyCriticalPathBand::LObData]( NULL )
        nb_op      := Float64( 0 )
        nb_rw      := Float64( 0 )
        needed_mem := Float64( 0 )
        
        def make_data_from_ops
            pass
            # for o in ops
                # if o->func
                    # needed_mem = max( needed_mem, o->func->produced_data_estimation( o->T, o->args ) )
                    # nb_op += o->func->nb_flop_estimation  ( o->T, o->args )
                    # nb_rw += o->func->nb_mem_rw_estimation( o->T, o->args )
        
        def mean_time
            return ( first_op->bottom_level + first_op->best_timing + last_op->bottom_level ) / 2
            
        def __for__( block )
            op := first_op
            while op
                block( op )
                op = op->next_in_strip
        
    static const PL := Ptr[LObData]
    static const PC := Ptr[CpuData]
    static const PN := Ptr[NetData]
    static const PM := Ptr[MemData]
    
    sch_data        := SplittedVec[LObData,256]()
    cpu_data        := SplittedVec[CpuData,256]()
    net_data        := SplittedVec[NetData,256]()
    mem_data        := SplittedVec[MemData,256]()
    additionnal_ops := SplittedVec[MultiPtr,256]()

    #~ ~#
    def init( lst_lazy_obj, computer_pool, current_operation_id )
        init_using_default_values( self )
        
        # find classes of CPU
        def cmp_cpu(x,y)
            return x->gflops==y->gflops and x->is_a_gpu==y->is_a_gpu and x->main_memory->read_rate==y->main_memory->read_rate
        cpu_classes := Vec[ Ptr[LazyComputerInfo::Cpu] ]()
        for c in computer_pool.cpus
            if not cpu_classes.has_item_that_checks( cmp_cpu[&c] )
                cpu_classes.push_back( &c )
        # init cpu_data, network_data, ...
        for c in computer_pool.cpus          c.ext_data = UntypedPtr( &cpu_data.push_back() )
        for c in computer_pool.networks      c.ext_data = UntypedPtr( &net_data.push_back() )
        for c in computer_pool.main_memories c.ext_data = UntypedPtr( &mem_data.push_back() )
        for c in computer_pool.ext_memories  c.ext_data = UntypedPtr( &mem_data.push_back() )
        
        # sch_data
        current_operation_id++
        for l in lst_lazy_obj
            init_ops_rec( l, sch_data, cpu_classes, current_operation_id )
        
        # critical paths
        update_bottom_and_higher_level( lst_lazy_obj, current_operation_id )
        
        # sort flatten_ops
        def sort_by_bottom_level( a, b )
            if a->bottom_level < b->bottom_level return true
            if a->bottom_level > b->bottom_level return false
            return a->higher_level < b->higher_level
        sorted_op := SplittedVec[ PL, 256 ]( sch_data.map( &_0 ) )
        sort( sorted_op, sort_by_bottom_level ) # @sorted_op[0] -> first op to execute
        
        # lazy_collection.display( x=>" "+x->data )
        
        # make strips
        strips := make_strips_( sorted_op, current_operation_id )
        # assemble strips according to nb cpus
        assemble_strips_( strips, computer_pool, lst_lazy_obj, current_operation_id )
        sort( sorted_op, sort_by_bottom_level ) # according to strip precedance
        
        # make instruction lists
        make_instruction_lists( sorted_op, computer_pool )
        
        # lazy_collection.display( " " + PL(_0->sch_data)->bottom_level + " / " + PL(_0->sch_data)->higher_level, x = true )
        # lazy_collection.display( " " + @_0->cpu, x = false )

    #~ ~#
    def write_graph( strips, function, f )
        #
        f <<< "digraph \"popo\" {"
        for s in strips
            f <<< "    subgraph cluster_$(&s) {"
            for n in s
                if n->prev_in_strip
                    f <<< "    node$(n->lop.ptr) -> node$(PL(n->prev_in_strip)->lop.ptr) [color=red];"
                # if n->next_in_strip
                    # f <<< "    node$(PL(n->next_in_strip)->lop.ptr) -> node$(n->lop.ptr) [color=green];"
            # f <<< "        fillcolor=grey"
            # f <<< "        style=filled"
            f <<< "        style=invis"
            f <<< "    }"
        for n in sch_data
            fc := ["grey","yellow","green","orange","violet","gold","cyan","aliceblue","darkolivegreen1","coral2","blue",
                    "darkgoldenrod3","darkgoldenrod4","deepskyblue1","deepskyblue2","deepskyblue3","deepskyblue4","hotpink","hotpink1","hotpink2",
                    "hotpink3","ivory","ivory1","ivory2","ivory3","orchid","orchid1","orchid2","orchid3","orchid4","palegoldenrod","palegreen",
                    "palegreen1","palegreen2","palegreen3","palegreen4","paleturquoise","paleturquoise1","paleturquoise2","paleturquoise3",
                    "paleturquoise4","palevioletred","palevioletred1","palevioletred2","palevioletred3","palevioletred4","papayawhip",
                    "peachpuff","peachpuff1","peachpuff2","peachpuff3","peachpuff4","peru","pink","pink1","pink2","pink3","pink4","plum",
                    "plum1","plum2","plum3","plum4","powderblue"][ n.strip_nb + (n.strip_nb<0) ]
            f <<< "    node$(n.lop.ptr) [label=\"$(function(n))\",fontsize=14,fillcolor=$fc,style=filled];"
            for d in n.lop->args
                l := Float64(Int32(n.best_timing*1e6))/100
                f <<< "    node$(n.lop.ptr) -> node$(d.ptr);" # [constraint=false] [minlen=$l]
            # if n.prev_in_strip
                # f <<< "    node$(n.lop.ptr) -> node$(PL(n.prev_in_strip)->lop.ptr) [color=\"red\"];"
            # if n.next_in_strip
                # f <<< "    node$(n.lop.ptr) -> node$(PL(n.next_in_strip)->lop.ptr) [color=\"green\"];"
        
        
        f <<< "}"
    
    #~ ~#
    def display( strips, function, fn = "res_cpr.dot", x = true )
        write_graph( strips, function, File( fn, "w" ) )
        system( "dot -Tps $fn > $fn.eps && epstopdf $fn.eps" )
        if x system( "gv $fn.eps" )
    
    #~ ~#
    def destroy
        for i in additionnal_ops
            delete i
        destroy_instanciated_attributes( self )
        
    #~ ~#
    static def init_ops_rec( lop, sch_data, cpu_classes, current_operation_id )
        if lop->op_id == current_operation_id
            return none # already registered ?
        lop->op_id = current_operation_id
        
        # room in sch_data
        sd := &sch_data.push_back()
        lop->sch_data.init( sd )
        sd->lop = lop
        
        # data in sch_data
        sd->produced_data_estimation = lop->T.byte_size
        if lop->func
            sd->produced_data_estimation += lop->func->produced_data_estimation( lop->T, lop->args )
        lop->produced_data = sd->produced_data_estimation
        # -> best_timing
        sd->best_timing = Float64::max_representable
        if lop->func and not lop->data
            for cc in cpu_classes
                sd->best_timing = min( sd->best_timing, lop->func->cost_estimation( lop->T, lop->args, @cc ) )
        else
            sd->best_timing = 1e-9
        # sd->best_timing = 1e-5
        
        # rec
        if not lop->data # no child or all child done -> we stop here
            for a in lop->args
                init_ops_rec( a, sch_data, cpu_classes, current_operation_id )

    #~ ~#
    def update_bottom_and_higher_level( lst_lazy_obj, current_operation_id )
        best_parallel_timing := Float64( 0 )
        #
        for s in sch_data
            s.bottom_level = 0
            s.higher_level = 0
        # bottom_level
        for l in lst_lazy_obj
            update_bottom_level_rec( PL(l->sch_data), current_operation_id, 0, best_parallel_timing )
        # higher_level
        for s in sch_data
            if s.in_front()
                update_higher_level_rec( &s, current_operation_id, best_parallel_timing )
    
    #~ -> used to find critical path ~#
    static def update_bottom_level_rec( sd, current_operation_id, current_bot_level, best_parallel_timing )
        new_bottom_level := current_bot_level + sd->best_timing
        if sd->bottom_level < new_bottom_level
            sd->bottom_level = new_bottom_level
            best_parallel_timing = max( best_parallel_timing, new_bottom_level )
            for a in sd->lop->args
                if a->op_id == current_operation_id
                    update_bottom_level_rec( PL( a->sch_data ), current_operation_id, new_bottom_level, best_parallel_timing )
            if sd->prev_in_strip
                update_bottom_level_rec( PL( sd->prev_in_strip ), current_operation_id, new_bottom_level, best_parallel_timing )

    #~ ~#
    static def update_higher_level_rec( sd, current_operation_id, new_higher_level )
        nh := new_higher_level
        for a in sd->lop->args
            if a->op_id == current_operation_id
                ad := PL(a->sch_data)
                nh = min( nh, ad->higher_level - ad->best_timing )
        if sd->higher_level < nh
            sd->higher_level = nh
            nh -= sd->best_timing
            for p in sd->lop->parents
                if p->op_id == current_operation_id
                    update_higher_level_rec( PL( p->sch_data ), current_operation_id, nh )
            if sd->next_in_strip
                update_higher_level_rec( PL( sd->next_in_strip ), current_operation_id, nh )

    #~ ~#
    def make_strips_( sorted_op, current_operation_id )
        strips := SplittedVec[ Strip, 32 ]()
        for op in sorted_op
            if op->strip_nb < 0
                strip_nb := strips.size
                n_strip := ref strips.push_back()
                n_strip.first_op = op
                make_strips_rec_( op, strip_nb, n_strip, current_operation_id )
                # display( strips, x => x.lop->repr + " " + x.strip_nb )
                n_strip.make_data_from_ops()
        return strips
                
    #~ ~#
    static def make_strips_rec_( op, strip_nb, current_strip, current_operation_id )
        op->prev_in_strip = current_strip.last_op
        if current_strip.last_op
            current_strip.last_op->next_in_strip = op
        current_strip.last_op = op
        op->strip_nb = strip_nb
        #
        best_po := PL( NULL )
        bot_lev := Float64( -1 )
        # find best parent -> the one which has greatest bottom_level
        for p in op->lop->parents
            if p->op_id == current_operation_id
                po := PL( p->sch_data )
                if po->strip_nb < 0 and po->bottom_level > bot_lev
                    best_po = po
                    bot_lev = po->bottom_level
        if best_po
            make_strips_rec_( best_po, strip_nb, current_strip, current_operation_id )
    
    #~ ~#
    static def intersection_interval( b0, s0, b1, s1 )
        b := max( b0-s0, b1-s1 )
        e := min( b0   , b1    )
        return ( e - b ) * ( e > b )
     
    #~ ~#
    class NbInInterval
        class Inter
            event := Float64( 0 ) # end
            sign := 0
        data := Vec[Inter]()
        
        def append_event( event, sign )
            for inter in data
                if event == inter.event
                    inter.sign += sign
                    return none
            data.push_back( event = event, sign = sign )
            sort( data, (x,y) => x.event > y.event )
            
        def append( b, e )
            append_event( b, 1 )
            append_event( e, -1 )
    
        def max_cum
            res := 0
            cum := 0
            for inter in data
                cum += inter.sign
                res = max( res, cum )
            return res
            
     
    #~  ~#
    def nb_needed_cpu( strips )
        ni := NbInInterval()
        for s in strips
            for o in s
                ni.append( o->bottom_level - o->best_timing, o->bottom_level )
        return ni.max_cum()
        
    #~ ~#
    def find_child_to_take_or_strip_to_assemble_( strips, best_pa, best_op, 
                best_hig_level_incr, best_strip_assembly_strip_0, best_strip_assembly_strip_1, best_strip_assembly_incr, nb_cpus )
        
        # look for a top level op of a strip to take within another strip
        for s in strips
            if s.first_op
                strip_nb := s.first_op->strip_nb
                for o in s
                    ch := PL( o->prev_in_strip )
                    if ch
                        d_lev := ch->bottom_level - ch->higher_level
                        for a in o->lop->args
                            if not PL(a->sch_data)->next_in_strip # strip_nb != strip_nb
                                hig_level_incr := d_lev + PL(a->sch_data)->best_timing 
                                if hig_level_incr <= 1e-6
                                    hig_level_incr = PL(a->sch_data)->needed_communication()
                                    if best_hig_level_incr > hig_level_incr
                                        best_hig_level_incr = hig_level_incr
                                        best_pa = o
                                        best_op = PL(a->sch_data)
        if best_hig_level_incr != Float64::max_representable
            return none
        
        # look for a top level op of a strip to take within another strip
        for s in strips
            if s.first_op
                strip_nb := s.first_op->strip_nb
                for o in s
                    ch := PL( o->prev_in_strip )
                    if ch
                        d_lev := ch->bottom_level - ch->higher_level
                        for a in o->lop->args
                            if not PL(a->sch_data)->next_in_strip # strip_nb != strip_nb
                                hig_level_incr := d_lev + PL(a->sch_data)->best_timing 
                                hig_level_incr /= PL(a->sch_data)->bottom_level
                                if best_hig_level_incr > hig_level_incr
                                    best_hig_level_incr = hig_level_incr
                                    best_pa = o
                                    best_op = PL(a->sch_data)
        # if best_hig_level_incr != Float64::max_representable
            # return none

        # if can't be executed in parallel, don't try to assemble strips
        if nb_needed_cpu( strips ) > nb_cpus
            return none
        # su := Float64(0)
        # for s in strips
            # for o in s
                # su += o->best_timing
        # info su, strips[0].first_op->higher_level * nb_cpus
        # if su > strips[0].first_op->higher_level * nb_cpus
            # return none
            
        # look for split assembly
        for s0 in strips
            for s1 in strips
                if &s0 != &s1 and s0.first_op and s1.first_op
                    incr := Float64( 0 )
                    for o0 in s0
                        for o1 in s1
                            incr += intersection_interval( o0->higher_level, o0->best_timing, o1->bottom_level, o1->best_timing )
                    if best_strip_assembly_incr > incr
                        best_strip_assembly_incr = incr
                        best_strip_assembly_strip_0 = &s0
                        best_strip_assembly_strip_1 = &s1
        
    #~ ~#
    def best_beginning_of( prev_pa )
        res := Float64( 0 )
        for p in prev_pa->lop->parents
            res = max( res, PL(p->sch_data)->bottom_level )
        if prev_pa->next_in_strip
            res = max( res, PL(prev_pa->next_in_strip)->bottom_level )
        return res
        
    #~ ~#
    def clear_bottom_level_rec( prev_op )
        if prev_op->bottom_level
            prev_op->bottom_level = 0
            prev_op->higher_level = 0
            for a in prev_op->lop->args
                clear_bottom_level_rec( PL(a->sch_data) )
            if prev_op->prev_in_strip
                clear_bottom_level_rec( PL(prev_op->prev_in_strip) )
        
    #~ ~#
    def assemble_strips_( strips, computer_pool, lst_lazy_obj, current_operation_id )
        nb_strips := strips.size
        nb_cpus := computer_pool.cpus.size
        #
        best_parallel_timing := strips[0].first_op->bottom_level
        cpt := 100
        while true
            def d( x )
                m := 1e5
                # return Int32(x.best_timing*m)
                b0 := Int32( ( x.bottom_level-x.best_timing ) * m )
                h0 := Int32( ( x.higher_level-x.best_timing ) * m )
                b1 := Int32( x.bottom_level * m )
                h1 := Int32( x.higher_level * m )
                return " $b0-$b1;$h0-$h1"
            # info cpt
            # display( strips, d, "img/res_$(cpt++)_dot", false )
            if nb_strips <= nb_cpus
                break
                
            # find a child of this strip to take within
            best_pa                     := Ptr[LObData]( NULL ) # best parent
            best_op                     := Ptr[LObData]( NULL ) # best child
            best_hig_level_incr         := Float64::max_representable
            best_strip_assembly_strip_0 := Ptr[Strip](NULL)
            best_strip_assembly_strip_1 := Ptr[Strip](NULL)
            best_strip_assembly_incr    := Float64::max_representable
            find_child_to_take_or_strip_to_assemble_( strips, best_pa, best_op, 
                best_hig_level_incr, best_strip_assembly_strip_0, best_strip_assembly_strip_1, best_strip_assembly_incr, nb_cpus )
            
            # choice of comb type
            if best_hig_level_incr <= best_strip_assembly_incr # or best_strip_assembly_incr > 1e-9 # + 1e5
                # take best_po in path
                if not best_pa
                    display( strips, x => x.lop->repr + " " + x.bottom_level )
                prev_pa := PL( best_pa->prev_in_strip )
                prev_op := PL( best_op->prev_in_strip )
                if prev_pa
                    prev_pa->next_in_strip = best_op
                else
                    strips[ best_pa->strip_nb ].first_op = best_op
                best_op->next_in_strip = best_pa
                best_pa->prev_in_strip = best_op
                best_op->prev_in_strip = prev_pa
                
                strips[ best_op->strip_nb ].last_op = prev_op
                if prev_op
                    prev_op->next_in_strip = NULL
                else
                    strips[ best_op->strip_nb ].first_op = NULL
                    
                best_op->strip_nb = best_pa->strip_nb
                nb_strips -= not prev_op
                
                # timings update
                update_bottom_and_higher_level( lst_lazy_obj, current_operation_id )
                # if prev_op
                    # beg_prev_op := best_beginning_of( prev_op )
                    # if beg_prev_op < prev_op->bottom_level - prev_op->best_timing
                        # clear_bottom_level_rec( prev_op )
                    # update_bottom_level_rec( prev_op, current_operation_id, beg_prev_op, best_parallel_timing )
                # if prev_pa
                    # beg_prev_pa := best_beginning_of( prev_pa )
                    # if beg_prev_pa < prev_pa->bottom_level - prev_pa->best_timing
                        # clear_bottom_level_rec( prev_pa )
                    # update_bottom_level_rec( prev_pa, current_operation_id, beg_prev_pa, best_parallel_timing )
                # for s in strips
                    # if s.first_op and s.first_op->in_front()
                        # update_higher_level_rec( s.first_op, current_operation_id, best_parallel_timing )
            else
                # print "yeap", best_strip_assembly_incr, best_hig_level_incr
                # info @best_strip_assembly_strip_0
                # for s in @best_strip_assembly_strip_0 info s->lop->repr
                # info @best_strip_assembly_strip_1
                # for s in @best_strip_assembly_strip_1 info s->lop->repr
                def push_( o, new_first, new_last, strip_nb )
                    o->strip_nb = strip_nb
                    #o->bottom_level = 0
                    o->prev_in_strip = new_last
                    if new_last
                        new_last->next_in_strip = o
                    new_last = o
                    if not new_first
                        new_first = o
                    o = o->next_in_strip
                    
                # joining of two strips
                nb_strips--
                new_first := Ptr[LObData]( NULL )
                new_last  := Ptr[LObData]( NULL )
                o0 := best_strip_assembly_strip_0->first_op
                o1 := best_strip_assembly_strip_1->first_op
                strip_nb := best_strip_assembly_strip_0->first_op->strip_nb
                while o0 or o1
                    if not o0
                        push_( o1, new_first, new_last, strip_nb )
                    else if not o1
                        push_( o0, new_first, new_last, strip_nb )
                    else if o0->higher_level > o1->bottom_level # or ( o0->higher_level == o1->bottom_level and o0->bottom_level > o1->bottom_level )
                        push_( o0, new_first, new_last, strip_nb )
                    else
                        push_( o1, new_first, new_last, strip_nb )
                
                best_strip_assembly_strip_0->first_op = new_first
                best_strip_assembly_strip_0->last_op  = new_last
                best_strip_assembly_strip_1->first_op = NULL
                best_strip_assembly_strip_1->last_op  = NULL
                
                # timings update
                update_bottom_and_higher_level( lst_lazy_obj, current_operation_id )
                # for s in @best_strip_assembly_strip_0
                    # s->bottom_level = new_last->bottom_level
                    # s->higher_level = new_last->bottom_level
                # update_bottom_level_rec( PL(new_last->prev_in_strip), current_operation_id, new_last->bottom_level, best_parallel_timing )
                # old_last_0->higher_level = old_last_0->bottom_level
                # for s in strips
                    # if s.first_op and s.first_op->in_front()
                        # update_higher_level_rec( s.first_op, current_operation_id, best_parallel_timing )
        # strip_nb -> cpu
        cpt = 0
        for s in strips
            if s.first_op
                for o in s
                    o->lop->cpu = &computer_pool.cpus[ cpt ]
                cpt ++
        
            
    #~ ~#
    def make_instruction_lists( sorted_op, computer_pool )
    
    
        # clear exec sim
        for cpu in computer_pool.cpus          PC( cpu.ext_data )->free_exec_sim()
        for mem in computer_pool.main_memories PM( mem.ext_data )->free_exec_sim()
        for net in computer_pool.networks      PN( net.ext_data )->free_exec_sim()
        for cpu in computer_pool.cpus          cpu.first_op_to_exec = NULL
    
        # register
        t0 := time_of_day_in_sec()
        for op in sorted_op
            op->lop->execute()
            # if not op->lop->cpu->last_op_to_exec
                # op->lop->cpu->first_op_to_exec = op->lop
                # op->lop->cpu->last_op_to_exec  = op->lop
            # else
                # op->lop->cpu->last_op_to_exec->next_op_to_exec = op->lop
                # op->lop->prev_op_to_exec = op->lop->cpu->last_op_to_exec
                # op->lop->cpu->last_op_to_exec = op->lop
            # op->lop->bottom_level = op->bottom_level
            
            # memory management
            used := ref PM( op->lop->cpu->main_memory->ext_data )->used
            used += op->produced_data_estimation
            # possible to free children ?
            for a in op->lop->args
                PL( a->sch_data )->nb_times_used++
                if PL( a->sch_data )->nb_times_used == a->cpt_use
                    used -= PL( a->sch_data )->produced_data_estimation
            # print op->bottom_level, used
            # print op->bottom_level-op->best_timing, used
            
        info time_of_day_in_sec() - t0
            
        return none
        
        
        #
        for op in sch_data
            info op.lop
        for op in sorted_op
            # children are serialized ?
            for a in op->lop->args
                pa := PL( a->sch_data )
                if pa->serialized_on
                    needed_time_to_deserialize := pa->serialized_on->read_rate * op->produced_data_estimation
                    op_before_deserialize := find_op_before_deserialize_( op->lop->cpu->instructions, needed_time_to_deserialize )
                    #
                    ni := new LazyObjectDeSerializer( object = a, mem = pa->serialized_on )
                    additionnal_ops.push_back( ni )
                    op->lop->cpu->instructions.insert_after( op_before_deserialize, ni )
            
            # push op
            info op->lop
            info op->lop->cpu->instructions.size
            info op->lop->cpu
            op->lop->cpu->instructions.push_back( op->lop )
            op->registered_in_instr = true
            used := ref PM( op->lop->cpu->main_memory->ext_data )->used
            used += op->produced_data_estimation
            
            # not enough memory ?
            while used > op->lop->cpu->main_memory->amount
                # find a non freed op with in memory data
                best_o := Ptr[MultiPtr]()
                best_t := Float64::max_representable
                for cpu in op->lop->cpu->main_memory->attached_cpus
                    for o in cpu->instructions
                        if o->is_a_LazyObject and o->cpt_use > PL( o->sch_data )->nb_times_used and not PL( o->sch_data )->serialized_on
                            t := Float64::max_representable / 2
                            for p in o->parents
                                if not PL( p->sch_data )->registered_in_instr
                                    t = min( t, PL( p->sch_data )->bottom_level )
                            if t == Float64::max_representable / 2 # it's better to take children with cpt_use > 1 due to active temporary variable
                                t = 0
                            if t < best_t
                                best_o = &o
                                best_t = t
                                
                # insert serialization instr
                if not best_o
                    break
                ext_mem := op->lop->cpu->ext_memories[0]
                for cpu in op->lop->cpu->main_memory->attached_cpus
                    ni := new LazyObjectSerializer( object = @best_o, mem = ext_mem )
                    additionnal_ops.push_back( ni )
                    cpu->instructions.insert_after( best_o, ni )
                #
                PL( (@best_o)->sch_data )->serialized_on = ext_mem
                used -= PL( (@best_o)->sch_data )->produced_data_estimation
            
            # possible to free children ?
            for a in op->lop->args
                PL( a->sch_data )->nb_times_used++
                if PL( a->sch_data )->nb_times_used == a->cpt_use
                    used -= PL( a->sch_data )->produced_data_estimation
                    
    def find_op_before_deserialize_( instructions, needed_time_to_deserialize )
        return &instructions.back
        # acc_time := Float64( 0 )
        # for o in op->lop->cpu->instructions.reversed
            # if o->is_a_LazyObject
                # if acc_time >= needed_time_to_deserialize # or op->lop->cpu->main_memory->used + >= ->lop->cpu->main_memory->
                    # break
                # acc_time += PL( o->sch_data )->timing
         
                
                       
                              
                                     
                                            
                                                   
                                                          
                                                                 

                
# ------------------------------------------------------------------------------------------------
#~ Sinnen Sousa -> "Scheduling tasks graphs on arbitrary processor architectures considering contention" ~#
# class LazySimpleContentionScheduling
    # flatten_ops := SplittedVec[ MultiPtr, 64 ]()
    # exec_list   := Vec[ LazyInstructionList ]() # one for each processor
    
    # def init( lst_lazy_obj, computer_pool, current_operation_id )
        # init_using_default_values( self )
        
        # # find classes of CPU
        # cpu_classes := VecUnique[ Vec[ Ptr[LazyComputerInfo::Cpu] ], (x,y) => ( x->gflops==y->gflops and x->is_a_gpu==y->is_a_gpu ) ]()
        # for c in computer_pool.cpus
            # cpu_classes.push_back( &c )
        
        # # update flatten_ops, get critical path, ...
        # current_operation_id++
        # for l in lst_lazy_obj init_and_append_to_flatten_ops_rec( l, flatten_ops, current_operation_id )
        # for l in lst_lazy_obj l->higher_level = 0
        # for l in lst_lazy_obj update_bottom_level_rec( l, cpu_classes, current_operation_id )
        # for l in lst_lazy_obj update_higher_level_rec( l, cpu_classes, current_operation_id )
        
        # # -> sort flatten_ops
        # def sort_by_bottom_level( a, b )
            # if a->bottom_level < b->bottom_level return true
            # if a->bottom_level > b->bottom_level return false
            # return a->higher_level < b->higher_level
        # sort( flatten_ops, sort_by_bottom_level )
        
        # # -> repartition ( which CPU for each task )
        # for lop in flatten_ops
            # if lop->func
                # # find cpu with lower finishing_time for this task
                # best_finishing_time := Float64::max_representable
                # best_cpu := Ptr[ LazyComputerInfo::Cpu ]( NULL )
                # for cc in computer_pool.cpus
                    # finishing_time := computer_pool.time_to_get_data( cc, lop->args, lop->func )
                    # finishing_time = max( finishing_time, cc.end_of_current_task )
                    # finishing_time += lop->func->cost_estimation( lop->T, lop->args, cc )
                    # if best_finishing_time > finishing_time
                        # best_finishing_time = finishing_time
                        # best_cpu = &cc
                # best_cpu->end_of_current_task = best_finishing_time
                # lop->finishing_time = best_finishing_time
                # lop->cpu = best_cpu
        
        # # -> compilation of instructions (@func) and network+HD directives
        # exec_list.size = max( computer_pool.cpus.map( _0.cpu_nb ) ) + 1
        # for cpu in computer_pool.cpus
            # exec_list[ cpu.cpu_nb ].cpu = &cpu
        # for lop in flatten_ops
            # num_cpu := lop->cpu->cpu_nb
            # exec_list[ num_cpu ].instructions.push_back(
                # func = lop->func,
                # data = NULL,
                # args = lop->args
            # )
            # lop->cpu->main_memory->used += lop->produced_data_estimation
            # if lop->cpu->main_memory->used > lop->cpu->main_memory->amount
                # info "bing from $(@cpu)"
            
            
    # def __for__( block )
        # for f in flatten_ops
            # if f->func
                # block( f )
        
    # static def init_and_append_to_flatten_ops_rec( lop, flatten_ops, current_operation_id )
        # if lop->op_id == current_operation_id
            # return none # already registered ?
        # lop->op_id = current_operation_id
        # flatten_ops.push_back( lop )
        # #
        # lop->produced_data_estimation = get_byte_size( lop->T )
        # if lop->func
            # lop->produced_data_estimation += lop->func->produced_data_estimation( lop->T, lop->args )
        # #
        # lop->bottom_level = 0
        # lop->higher_level = Float64::max_representable
        
        # # rec
        # if not lop->child_are_done() # no child or all child done -> we stop here
            # for a in lop->args
                # init_and_append_to_flatten_ops_rec( a, flatten_ops, current_operation_id )
        
    # static def update_bottom_level_rec( lop, cpu_classes, current_operation_id )
        # # best_timing
        # best_timing := Float64::max_representable
        # if lop->func
            # for cc in cpu_classes
                # best_timing = min( best_timing, lop->func->cost_estimation( lop->T, lop->args, @cc ) )
        # else
            # best_timing = 1e-9
        # #
        # new_bottom_level := lop->bottom_level + best_timing
        # for a in lop->args
            # if a->op_id == current_operation_id and a->bottom_level < new_bottom_level
                # a->bottom_level = new_bottom_level
                # update_bottom_level_rec( a, cpu_classes, current_operation_id )
    
    # static def update_higher_level_rec( lop, cpu_classes, current_operation_id )
        # # best_timing
        # best_timing := Float64::max_representable
        # if lop->func
            # for cc in cpu_classes
                # best_timing = min( best_timing, lop->func->cost_estimation( lop->T, lop->args, @cc ) )
        # else
            # best_timing = 0
        # #
        # new_higher_level := lop->higher_level + best_timing
        # for a in lop->args
            # if a->op_id == current_operation_id and a->higher_level > new_higher_level
                # a->higher_level = new_higher_level
                # update_higher_level_rec( a, cpu_classes, current_operation_id )
