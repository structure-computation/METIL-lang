import "metil_base_cpp_generator.met"
import "lazy_scheduling.met"
# import "lazy_scheduling_1_cpu.met"

#~  ~#
class LazyComputerInfo
    #~ a network link ~#
    class Network
        def get_transfer_rate( cpu_0, cpu_1 )
            if cpu_0.name == cpu_1.name
                return 0
            return 1
        def get_transfer_latency( cpu_0, cpu_1 )
            if cpu_0.name == cpu_1.name
                return 0
            return 1
        def get_transfer_time( cpu_0, cpu_1, arg )
            return get_transfer_rate( cpu_0, cpu_1 ) * arg->produced_data_estimation + get_transfer_latency( cpu_0, cpu_1 )
        ext_data := UntypedPtr() # @see LazyScheduling
    
    #~ external memory ( hard disk, flash disk... ) that can be used for temporary storage ~#
    class ExternalMemory
        read_rate     := Float64( 140e6 ) # Bytes/s
        write_rate    := Float64( 100e6 ) # Bytes/s
        amount        := Float64( 200e9 ) # Bytes
        attached_cpus := SplittedVec[ Ptr[LazyComputerInfo::Cpu], 8 ]()
        ext_data      := UntypedPtr() # @see LazyScheduling
        used          := Float64( 0 ) # Bytes
    
    #~  ~#
    class MainMemory
        read_rate     := Float64( 10e9 ) # Bytes/s 6.4e9
        write_rate    := Float64( 10e9 ) # Bytes/s 6.4e9
        amount        := Float64( 2e9   ) # Bytes
        attached_cpus := SplittedVec[ Ptr[LazyComputerInfo::Cpu], 8 ]()
        ext_data      := UntypedPtr() # @see LazyScheduling
        used          := Float64( 0 ) # Bytes
    
    #~  ~#
    class Cpu
        name          := "localhost"
        cpu_nb        := 0
        gflops        := Float64( 10e9 )
        is_a_gpu      := false
        main_memory   := Ptr[ LazyComputerInfo::MainMemory ]()
        ext_memories  := Vec[ Ptr[ LazyComputerInfo::ExternalMemory ] ]()
        ext_data      := UntypedPtr() # @see LazyScheduling
        
        # semaphore     := Semaphore()
        first_op_to_exec := MultiPtr( NULL )
        last_op_to_exec  := MultiPtr( NULL )
        # instructions  := SplittedVec[ MultiPtrWithCptUse, 32 ]() # LazyObject
        
        #
        def do_instructions # exec operation that must be done on self
            for i in instructions
                # wait for children from other CPUS
                for c in i->args
                    if c->cpu != &self
                        semaphore.wait()
                # execute
                i->execute()
                # say ok to parents in other CPUS
                for p in i->parents
                    if p->cpu != &self
                        p->cpu->semaphore.post()
        
        #
        def write_to_stream( stream )
            stream << name << "[$cpu_nb]"

#~  ~#
class LazyComputerPool
    networks      := SplittedVec[ LazyComputerInfo::Network       , 8 ]()
    ext_memories  := SplittedVec[ LazyComputerInfo::ExternalMemory, 8 ]()
    main_memories := SplittedVec[ LazyComputerInfo::MainMemory    , 8 ]()
    cpus          := SplittedVec[ LazyComputerInfo::Cpu           , 8 ]() # one entry for each cpu in each computer
        
    def init( nb_cpus ) when nb_cpus.is_a_number
        init_using_default_values( self )
        networks     .push_back()
        ext_memories .push_back()
        main_memories.push_back()
        for i in 0 .. nb_cpus
            n_cpu := &cpus.push_back()
            n_cpu->cpu_nb = i
            n_cpu->main_memory  = main_memories.begin
            n_cpu->main_memory->attached_cpus.push_back( n_cpu )
            n_cpu->ext_memories = [ ext_memories.begin ]
            for e in n_cpu->ext_memories
                e->attached_cpus.push_back( n_cpu )
        #
        update_cpu_nb()
            
    def update_cpu_nb
        for c, cpt in cpus, 0...
            c.cpu_nb = cpt
    
    def time_to_get_data( cpu, args, func )
        # TODO -> network contention
        res := Float64( 0 )
        for a in args
            tmp := Float64::max_representable
            for n in networks
                tmp = min( tmp, n.get_transfer_time( cpu, @a->cpu, a ) )
            res = max( res, a->finishing_time + tmp )
        return res
        
# ------------------------------------------------------------------------------------------------

#~  ~#
class LazyCollection
    all_LazyData         := SplittedVec[ MultiPtr, 64 ]() # should be of type LazyObject[ Something ]
    computer_pool        ~= LazyComputerPool
    current_operation_id := Int64(0) #
    
    def init( nb_cpu = 1 )
        init_using_default_values( self )
        computer_pool.init( nb_cpu )
        
    def destroy
        computer_pool.destroy()
        destroy_instanciated_attributes( self )
        
    def add( ld )
        all_LazyData.push_back( ld )
        ld->cpu = computer_pool.cpus.begin # on the first cpu by default
    
    def remove( ld )
        ind := all_LazyData.index_of_first_item_equal_to( ld, -1 )
        assert( ind >= 0, "weird" )
        all_LazyData.remove_unordered( ind )
    
    # do the job
    def update( lst_lazy_obj )
        # if already done
        if all( lst_lazy_obj.map( x => x->data ) )
            return none
        
        # else -> schedule
        scs := LazyCriticalPathBand( lst_lazy_obj, computer_pool, current_operation_id )
        # scs := LazyScheduleCpp( lst_lazy_obj, computer_pool, current_operation_id )
        # scs := LazyScheduleOneCpu( lst_lazy_obj, computer_pool, current_operation_id )
        
        # execute
        t0 := time_of_day_in_sec()
        op := computer_pool.cpus[0].first_op_to_exec
        while op
            op->execute()
            op = op->next_op_to_exec
        info time_of_day_in_sec() - t0
    
        # lazy_collection.display( " " + @_0->cpu )
        
        # display()
        # for cpu in computer_pool.cpus
            # thread_pool.push_back(
                # pthread_create( cpu.exec_list, scs )
            # )
        # for th in thread_pool
            # pthread_join( th )
    
    def write_graph( function, f )
        f <<< "digraph \"popo\" {"
        for n in all_LazyData
            f <<< "    node$(n.ptr) [label=\"$(n->repr)$(function(n))\",fontsize=14];"
            for d in n->args
                f <<< "    node$(n.ptr) -> node$(d.ptr);"
        f <<< "}"
    
    def display( function, fn = ".res.dot", x = true )
        write_graph( function, File( fn, "w" ) )
        system( "dot -Tps $fn > $fn.eps && epstopdf $fn.eps" )
        if x
            system( "gv $fn.eps" )
        
        
    def display_repartition( f, scs )
        # for cpu in computer_pool.cpus
        for li in scs.exec_list
            f <<< "in CPU $(@li.cpu):"
            for n in li.instructions
                f <<< "  $n"

lazy_collection := LazyCollection()

# ------------------------------------------------------------------------------------------------

#~
~#
class LazyObject[ T ]
    property is_a_LazyObject
    
    data            := Ptr[ T ]( NULL )
    func            := MultiPtr( NULL ) # function or class with apply() method
    args            := Vec[ MultiPtrWithCptUse ]() # should be of type LazyObject[ Something ]
    parents         := Vec[ MultiPtr ]() # should be of type LazyObject[ Something ]
    cpt_use         := 0
    nb_times_used   := 0
    done            := false # needed because data NULL can mean data on HD
    
    op_id           := Int64( 0 ) # to be compared to current_operation_id
    cpu             := Ptr[ LazyComputerInfo::Cpu ](NULL) # 
    sch_data        := UntypedPtr() # additional data for the scheduler
    next_op_to_exec := MultiPtr()
    prev_op_to_exec := MultiPtr()
    produced_data   := Float64( 0 )
    bottom_level    := Float64( 0 )
    
    def init
        init_using_default_values( self )
        lazy_collection.add( &self )

    def init( function ) pertinence -1
        # print "init $(&self) $(@function)"
        init()
        func = function
    
    def init( value ) pertinence -1
        # print "init $(&self) $(@function)"
        init()
        data = new T( value )
        
    def destroy
        # remove in lazy collection
        lazy_collection.remove( &self )
        # remove in parents of children
        # for c in args
            # ind := c->parents.index_of_first_item_equal_to( &self )
            # if ind >= 0
                # c->parents.remove_unordered( ind )
        #
        # print "destroy $(&self) " + repr
        delete data
        delete func
        destroy_instanciated_attributes( self )
    
    def execute
        if func and not data
            # print "exec $(&self) " + repr
            # look for a children that could be used as an input/output arg
            for na in func->args_that_can_be_used_as_io
                if args[na]->nb_times_used + 1 == args[na]->cpt_use
                    assert( T == args[na]->T, "data and args[$na] are not of same type ( $T != $(args[na]->T) )" )
                    # data = args[na]->data
                    # args[na]->data = NULL # so it won't be freed
                    info na
            # exec
            if not data
                data = allocate( T )
            (@func)( data, args )
            done = true
            
            # memory
            cpu->main_memory->used += produced_data
            # free args if possible
            for a in args
                a->nb_times_used++
                if a->nb_times_used == a->cpt_use
                    cpu->main_memory->used -= a->produced_data
                    delete a->data
                    
            # if not enough memory
            # if cpu->main_memory->used > cpu->main_memory->amount
                # look for something to free
                    
    def add_child( ch )
        args.push_back( ch )
        ch->parents.push_back( &self )
        
    def child_are_done
        return all( args.map( _0->data ) )
        
    def timing_estimation( cpu )
        if not func
            return Float64( 1e-10 )
        return func->nb_flop_estimation( T, args ) / cpu.gflops + func->nb_mem_rw_estimation( T, args ) / cpu.main_memory->read_rate
    
    def get_repr
        if func
            if func->has_repr
                return func->repr()
            return String( func->type )
        if data and T == Float64
            return String( @data )
        return String( T )

#~
~#
class LazyObjectSerializer
    static const args := []
    static const parents := []
    
    obj     := MultiPtr( NULL ) # function or class with apply() method
    ext_mem := Ptr[ LazyComputerInfo::ExternalMemory ]()
    cpt_use := 0
    
    def init( object, mem ) pertinence -2
        init_using_default_values( self )
        obj = object
        ext_mem = mem
    def execute
        cpu->main_memory->used -= obj->produced_data
        # print "serialize $obj " + obj->repr

#~
~#
class LazyObjectDeSerializer
    static const args := []
    static const parents := []
    
    obj     := MultiPtr( NULL ) # function or class with apply() method
    ext_mem := Ptr[ LazyComputerInfo::ExternalMemory ]()
    cpt_use := 0
    
    def init( object, mem ) pertinence -2
        init_using_default_values( self )
        obj = object
        ext_mem = mem
    def execute
        cpu->main_memory->used += obj->produced_data
        # print "deseriali $obj " + obj->repr

# ------------------------------------------------------------------------------------------------

# ancestor of lazy functions 
class LazyFunc
    # -> assuming that we need room for a new T + 0 bytes
    def produced_data_estimation( T, args ) pertinence 0
        return 0
    # -> nb read and writes (in bytes) during the procedure (including production of output) in main memory
    def nb_mem_rw_estimation( T, args ) pertinence 0
        return 0
    # -> nb read and writes (in bytes) during the procedure (including production of output) in main filesystem
    def nb_file_rw_estimation( T, args ) pertinence 0
        return 0
    # -> nb floating point operations
    def nb_flop_estimation( T, args ) pertinence 0
        return 0

    #
    def cost_estimation( T, args, cpu )
        res := nb_flop_estimation( T, args ) / cpu.gflops
        res += nb_mem_rw_estimation( T, args ) / cpu.main_memory->read_rate
        if cpu.ext_memories.size
            res += nb_file_rw_estimation( T, args ) / cpu.ext_memories[0]->read_rate
        return res
    # if nb_times_used == cpt_use and can_be_used_as_io, data points to args[n]
    static const args_that_can_be_used_as_io := []
            
    
# ------------------------------------------------------------------------------------------------
        
# class LazyInstruction
    # func := UntypedPtrAndType()
    # data := UntypedPtrAndType()
    # args := Vec[UntypedPtrAndType]()

    # def execute
        # if func
            # data = allocate( T )
            # (@func)( data, args )
    
    # def write_to_stream( stream )
        # if func
            # if func->has_repr
                # stream << func->repr()
            # else 
                # stream << @func
        # else if data.typ
            # stream << "known " << ptr_on_type_to_def( data.typ )
        # else 
            # stream << "?"
    

# class LazyInstructionList
    # instructions := SplittedVec[LazyInstruction,16]()
    # cpu := Ptr[ LazyComputerInfo::Cpu ]()
