# # fn := "paint_function"
# # File( "$fn.cpp", "w" ) <<<<
    # # #include <QtGui/QPainter>
    # # #include <QtGui/QWidget>
    # # extern "C" void paint_function( QWidget *qw, int, QPaintEvent * ) {
        # # int frameNo = 50;
        # # QPainter painter(qw);
        # # painter.setRenderHint(QPainter::Antialiasing, true);
        # # painter.translate(qw->width() / 2, qw->height() / 2);
        # # for (int diameter = 0; diameter < 256; diameter += 9) {
            # # int delta = abs((frameNo % 128) - diameter / 2);
            # # int alpha = 255 - (delta * delta) / 4 - diameter;
            # # if (alpha > 0) {
                # # painter.setPen(QPen(QColor(0, diameter / 2, 127, alpha), 3));
        
                # # painter.drawEllipse(QRectF(-diameter / 2.0, -diameter / 2.0,
                                        # # diameter, diameter));
            # # }
        # # }
    # # }

# # if not last_modification_time_or_zero_of_file_named( "$fn.so" )
    # # cmd := "g++ -I$(get_QT_INCLUDE_DIR()) -fPIC -shared $fn.cpp -o $fn.so"
    # # info cmd
    # # if system( cmd )
        # # return 1

# # dl := DlLoader( "./$fn.so" )
# # if not dl
    # # info dl.get_last_error()
    # # return 1

# # fu := dl.find_symbol( "paint_function" )
# # if not fu
    # # info dl.get_last_error()
    # # return 1

# # d1 := DisplayWindow_( 2, fu )
# # d2 := DisplayWindow_( 2, fu )

# # a := symbol("a")
# # beg := symbol("beg")
# # end := symbol("end")
# # cut := symbol("cut")
# # res := integration( heaviside( a - cut ), a, beg, end )
# # info res.subs( [beg end cut], [0 1 0.1] )
# # info res.subs( [beg end cut], [0 1 0.9] )
# # info res.subs( [beg end cut], [1 0 0.1] )
# # info res.subs( [beg end cut], [1 0 0.9] )

# # info integration( heaviside( a - cut ), a, 0, 1 ).subs( cut, -1.1 )
                # # painter.drawEllipse(QRectF(-diameter / 2.0, -diameter / 2.0,
                                        # # diameter, diameter));
            # # }
        # # }
    # # }

# # if not last_modification_time_or_zero_of_file_named( "$fn.so" )
    # # cmd := "g++ -I$(get_QT_INCLUDE_DIR()) -fPIC -shared $fn.cpp -o $fn.so"
    # # info cmd
    # # if system( cmd )
        # # return 1

# # dl := DlLoader( "./$fn.so" )
# # if not dl
    # # info dl.get_last_error()
    # # return 1

# # fu := dl.find_symbol( "paint_function" )
# # if not fu
    # # info dl.get_last_error()
    # # return 1

# # d1 := DisplayWindow_( 2, fu )
# # d2 := DisplayWindow_( 2, fu )
# # a := symbol("a")
# # b := symbol("b")
# # beg := symbol("beg")
# # end := symbol("end")
# # cut0 := symbol("c_0")
# # cut1 := symbol("c_1")
# # cut2 := symbol("c_2")

# # res := integration( heaviside( e - 1 ) * heaviside( 2 * a - 2 ), a, 0, 3 )
# # info res

# # info res.subs( [cut0 cut1 cut2], [0.4, 0.5, 0.4] )
# # info res.subs( [cut0 cut1 cut2], [0.5, 0.5, 0.5] )
# # info res.subs( [cut0 cut1 cut2], [0.0, 0.0, 0.0] )
# # info res.subs( [cut0 cut1 cut2], [1.0, 1.0, 1.0] )
# # plot( (-100..300)/100, res )
# # res.display_tex( false )

# # info res.subs( [beg end cut], [0 1 0.9] )
# # info res.subs( [beg end cut], [0 1 0] )
# # info res.subs( [beg end cut], [0 1 1] )
# # info res.subs( [beg end cut], [1 0 0.1] )
# # info res.subs( [beg end cut], [1 0 0.9] )
# # info res.subs( [beg end cut], [1 0 0] )
# # info res.subs( [beg end cut], [1 0 1] )
# # e := integration( heaviside( cut - a ), a, 0, 1 )
# # info e.subs( cut, -1.1 )
# # info e.subs( cut, -0.1 )
# # info e.subs( cut,  0.1 )
# # info e.subs( cut,  0.9 )
# # info e.subs( cut,  1.1 )

# # info res.subs( [beg end cut], [0, 1, -1.1] )
# # info res.subs( [beg end cut], [1, 0, -1.1] )

# # info res.subs( [beg end cut], [0 1 1.1] )
# # info res.subs( [beg end cut], [1 0 1.1] )
# # info integration( heaviside( a - 0.1 ), a, 0, 1 )



import "EF/std_elements.met"

# # e := SymbolicElement[Triangle_6]()

# # e.integration( 1 ).display_tex()


# def f
    # e1 := SymbolicElement[Triangle]()
    # e2 := SymbolicElement[Triangle]()
    
    # e1.pos_nodes = [
        # [0 0],
        # [0 1],
        # [1 0]
    # ]
    
    # x := symbol("x")
    # # x = 0.45
    # e2.pos_nodes = [
        # [x+0, 0],
        # [x+0, 1],
        # [x+1, 0]
    # ]
    
    # # v0 := symbol("\\eta")
    # # v0.set_beg_value( 0.0, false )
    # # v0.set_end_value( 1.0, false )
    # # integration( e2.point_is_inside( e1.pos ).subs( e1.var_inter[0], v0 ), e1.var_inter[1], 0, 1 - v0 ).display_tex()
    
    # # [ e1.point_is_inside( e1.pos ) e2.point_is_inside( e1.pos ) ].display_tex()
    
    
    # # vi := e2.var_inter_for_pos( e1.pos )
    # # r := e2.var_inter_is_inside( e1.pos )
    # # vi.display_tex()
    # r := e1.integration( e2.point_is_inside( e1.pos ), false )
    # # r := e1.bestial_num_integration( e2.point_is_inside( e1.pos ), false, 10 )
    # plot( (-100..200)/100, r )
    # # info r

# def g
    # e := SymbolicElement[Triangle]()
    
    # e.pos_nodes = [
        # [1 0],
        # [1 1],
        # [0 1]
    # ]
    
    # x := symbol("x")
    # a := symbol("a")
    # r := e.integration( heaviside( a * e.pos[0] - x ), false )
    # plot( (-1000..2000)/1000, r.subs( a, 1 ) )
    # # info r

# def h
    # eta := symbol("\\eta")
    # x := symbol("x")
    # a := symbol("a")
    # r :=  (1-heaviside(-(1.0/2.0*(1-eta)-(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a)))*(1-heaviside(-1.0/2.0*(1-eta)-(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a)))-heaviside(1.0/2.0*(1-eta)-(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a))*(1-heaviside(1.0/2.0*(1-eta)+(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a))))*(1-eqz(a))*(1.0/2.0*(1-eta)-(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a))*heaviside(a*(1-1.0/2.0*(1.0/2.0*(1-eta)-(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a)))-x)+(heaviside(1.0/2.0*(1-eta)-(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a))*(1-heaviside(1.0/2.0*(1-eta)+(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a)))+heaviside(-(1.0/2.0*(1-eta)-(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a)))*(1-heaviside(-1.0/2.0*(1-eta)-(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a))))*(1-eta)*heaviside(a*(1-1.0/2.0*(1-eta))-x)+(1-heaviside(-(1.0/2.0*(1-eta)-(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a)))*(1-heaviside(-1.0/2.0*(1-eta)-(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a)))-heaviside(1.0/2.0*(1-eta)-(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a))*(1-heaviside(1.0/2.0*(1-eta)+(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a))))*(1-eqz(a))*(1.0/2.0*(1-eta)+(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a))*heaviside(a*(1-1.0/2.0*(3.0/2.0*(1-eta)-(a*(1-1.0/2.0*(1-eta))-x)/(eqz(a)-a)))-x)

    # r = integration( r, eta, 0, 1 )
    # plot( (-1000..2000)/1000, r.subs( a, 1 ) )
    
    # # pl := PyLabPlot()
    # # pl.plot( (-1000..2000)/1000, r.subs( [a x], [1 0.49] ) )
    # # pl.plot( (-1000..2000)/1000, r.subs( [a x], [1 0.51] ) )
    # # pl.plot( (-1000..2000)/1000, r.subs( [a x], [1 0.60] ) )
    # # pl.show()

# # g()
# # eta := symbol("\\eta")
# # eta.set_beg_value( 0.0, false )
# # eta.set_end_value( 1.0, false )

# # info ( 1 - eta ).beg_value_valid()
# # info ( 1 - eta ).end_value_valid()

# # info ( 1 - eta ).beg_value_valid()
# # info ( 1 - eta ).end_value_valid()

# # x := 0.0
# # eta := symbol("\\eta")
# # # eta.set_beg_value( 0.0, false )
# # # eta.set_end_value( 1.0, false )

# # res := (1-heaviside(-1-(x-eta))*heaviside(-x)-heaviside(x)*heaviside(1+x-eta))*(1+x-eta)*heaviside(eta-x)*heaviside(1+x-eta)+(heaviside(-1-(x-eta))*(1-heaviside(x))+heaviside(1+x-eta)*(1-heaviside(-x)))*(1-eta)*heaviside(eta-x)*heaviside(x+1.0/2.0*(1-eta))-(1-heaviside(-1-(x-eta))*heaviside(-x)-heaviside(x)*heaviside(1+x-eta))*x*heaviside(x)*heaviside(eta-x)

# # res.display_tex()
# # integration( res, eta, 0, 1 ).display_tex()
# # plot( (0..101)/100, res )

# # v := VarArgs()
# # v.push_unnamed( 0 .. 5 )
# # v.push_unnamed( 0 .. 10 )

# # for i in rectilinear( v )
    # # info i

# def t
    # n := Mat[Op     ,Gen[3,2]]( function = x => symbol("n[$(x[0]),$(x[1])]") )
    # r := Mat[Float64,Gen[3,2]]( [0,0 0,1 1,0] )
    
    # expr := Mat[Op]([
        # 1.0/4.0*(2*pow(n[2,0]-n[0,0]-(n[2,1]-n[0,1]),2)+pow(n[1,1]-n[0,1]-(n[1,0]-n[0,0]),2))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(2*(n[2,1]-n[0,1])*(n[2,0]-n[0,0]-(n[2,1]-n[0,1]))-(n[1,1]-n[0,1])*(n[1,1]-n[0,1]-(n[1,0]-n[0,0])))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*((n[1,0]-n[0,0])*(n[1,1]-n[0,1]-(n[1,0]-n[0,0]))-2*(n[2,0]-n[0,0])*(n[2,0]-n[0,0]-(n[2,1]-n[0,1])))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(n[2,0]-n[0,0]-(n[2,1]-n[0,1]))*(n[1,1]-n[0,1]-(n[1,0]-n[0,0]))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(n[2,1]-n[0,1])*(n[1,1]-n[0,1]-(n[1,0]-n[0,0]))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # (-1.0/4.0)*(n[2,0]-n[0,0])*(n[1,1]-n[0,1]-(n[1,0]-n[0,0]))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1]))
        
        # 1.0/4.0*(2*(n[2,1]-n[0,1])*(n[2,0]-n[0,0]-(n[2,1]-n[0,1]))-(n[1,1]-n[0,1])*(n[1,1]-n[0,1]-(n[1,0]-n[0,0])))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(pow(n[1,1]-n[0,1],2)+2*pow(n[2,1]-n[0,1],2))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(-(n[1,0]-n[0,0])*(n[1,1]-n[0,1])-2*(n[2,0]-n[0,0])*(n[2,1]-n[0,1]))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # (-1.0/4.0)*(n[1,1]-n[0,1])*(n[2,0]-n[0,0]-(n[2,1]-n[0,1]))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # (-1.0/4.0)*(n[1,1]-n[0,1])*(n[2,1]-n[0,1])/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(n[2,0]-n[0,0])*(n[1,1]-n[0,1])/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1]))
        
        # 1.0/4.0*((n[1,0]-n[0,0])*(n[1,1]-n[0,1]-(n[1,0]-n[0,0]))-2*(n[2,0]-n[0,0])*(n[2,0]-n[0,0]-(n[2,1]-n[0,1])))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(-(n[1,0]-n[0,0])*(n[1,1]-n[0,1])-2*(n[2,0]-n[0,0])*(n[2,1]-n[0,1]))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(2*pow(n[2,0]-n[0,0],2)+pow(n[1,0]-n[0,0],2))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(n[1,0]-n[0,0])*(n[2,0]-n[0,0]-(n[2,1]-n[0,1]))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(n[1,0]-n[0,0])*(n[2,1]-n[0,1])/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # (-1.0/4.0)*(n[1,0]-n[0,0])*(n[2,0]-n[0,0])/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1]))
        
        # 1.0/4.0*(n[2,0]-n[0,0]-(n[2,1]-n[0,1]))*(n[1,1]-n[0,1]-(n[1,0]-n[0,0]))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # (-1.0/4.0)*(n[1,1]-n[0,1])*(n[2,0]-n[0,0]-(n[2,1]-n[0,1]))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(n[1,0]-n[0,0])*(n[2,0]-n[0,0]-(n[2,1]-n[0,1]))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(pow(n[2,0]-n[0,0]-(n[2,1]-n[0,1]),2)+2*pow(n[1,1]-n[0,1]-(n[1,0]-n[0,0]),2))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*((n[2,1]-n[0,1])*(n[2,0]-n[0,0]-(n[2,1]-n[0,1]))-2*(n[1,1]-n[0,1])*(n[1,1]-n[0,1]-(n[1,0]-n[0,0])))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(2*(n[1,0]-n[0,0])*(n[1,1]-n[0,1]-(n[1,0]-n[0,0]))-(n[2,0]-n[0,0])*(n[2,0]-n[0,0]-(n[2,1]-n[0,1])))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1]))
        
        # 1.0/4.0*(n[2,1]-n[0,1])*(n[1,1]-n[0,1]-(n[1,0]-n[0,0]))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # (-1.0/4.0)*(n[1,1]-n[0,1])*(n[2,1]-n[0,1])/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(n[1,0]-n[0,0])*(n[2,1]-n[0,1])/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*((n[2,1]-n[0,1])*(n[2,0]-n[0,0]-(n[2,1]-n[0,1]))-2*(n[1,1]-n[0,1])*(n[1,1]-n[0,1]-(n[1,0]-n[0,0])))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(pow(n[2,1]-n[0,1],2)+2*pow(n[1,1]-n[0,1],2))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(-(n[2,0]-n[0,0])*(n[2,1]-n[0,1])-2*(n[1,0]-n[0,0])*(n[1,1]-n[0,1]))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1]))
        
        # (-1.0/4.0)*(n[2,0]-n[0,0])*(n[1,1]-n[0,1]-(n[1,0]-n[0,0]))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(n[2,0]-n[0,0])*(n[1,1]-n[0,1])/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # (-1.0/4.0)*(n[1,0]-n[0,0])*(n[2,0]-n[0,0])/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(2*(n[1,0]-n[0,0])*(n[1,1]-n[0,1]-(n[1,0]-n[0,0]))-(n[2,0]-n[0,0])*(n[2,0]-n[0,0]-(n[2,1]-n[0,1])))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(-(n[2,0]-n[0,0])*(n[2,1]-n[0,1])-2*(n[1,0]-n[0,0])*(n[1,1]-n[0,1]))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1])),
        # 1.0/4.0*(pow(n[2,0]-n[0,0],2)+2*pow(n[1,0]-n[0,0],2))/((n[1,0]-n[0,0])*(n[2,1]-n[0,1])-(n[2,0]-n[0,0])*(n[1,1]-n[0,1]))
    # ])
    # # for i,j in rectilinear( expr.sizes )
        # # expr[i,j] *= i==1 and j==0
    
    # resu := Mat[Float64,Gen[expr.nb_rows]]()
    
    # as := AsmWriter()
    # as.add_association( n, &r )
    # for i, j in rectilinear( expr.sizes )
        # as.add( &resu[i,j], expr[i,j], reassign )
    # co := as.to_code()
    # co.execute()
    
    # reso := Mat[Float64]( expr.subs( Vec[Op](n.values), Vec[Op](r.values) ) )
    # infon reso
    # infon resu
    # info ( reso - resu ) : ( reso - resu )
    # # as.display_graphviz()
    
    # # expr[0,0].display_graphviz()
# t()

def test_564
    v := Vec[Float64,2]( 666 )
    n := Vec[Op     ,4]( function = x => symbol("n_$x") )
    r := Vec[Float64,4]( function = x => x+1 )
    s := Vec[Int64  ,4]( function = x => x+1 )
    expr := heaviside( n[0] - 2 )
    
    as := AsmWriter()
    as.add_association( n, &r )
    as.add( &v[0], expr, reassign )
    co := as.to_code()
    co.execute()
    
    info Float64( expr.subs( n, s ) )
    info v[ 0 ]
    # expr.display_tex()
    
test_564()

# def test_17
    # e := SymbolicElement[Triangle]()
    
    # p_syms := Vec[Op]()
    # p := e.new_variable( "p", sym = p_syms )
    # r := e.integration( heaviside( p ) )
    
    # a := symbol("a")
    # r = r.subs( e.pos_nodes[0]+++e.pos_nodes[1]+++e.pos_nodes[2]+++p_syms, [0, 0, 1, 0, 0, 1,  a, a+1, a] )
    # # info r
    # plot( (-100..200)/100, r )
    
# # test_17()

# e := SymbolicElement[Hexa]()

# e.pos_nodes = e.points
# e.pos.display_tex()

# base := Vec[Op]()
# for order in 1 .. 4
    # for comb in ConstantSumList( sum = order, list_size = 2 )
        # base.push_back( product( e.var_inter ^ comb ) )

# coeff_dep_expr := Vec[ Vec[ Op, base.size ], 2 ]()
# coeff_dep_test := Vec[ Vec[ Op, base.size ], 2 ]()
# sym_dep_expr := Vec[ Op ]()
# sym_dep_test := Vec[ Op ]()
# dep := Vec[ Op, e.dim ]()
# tep := Vec[ Op, e.dim ]()
# for d in 0 .. e.dim
    # for x in 0 .. base.size
        # coeff_dep_expr[ d ][ x ] = symbol("U^($x)_$d")
        # coeff_dep_test[ d ][ x ] = symbol("{U^($x)_$d}^*")
        # sym_dep_expr.push_back( coeff_dep_expr[ d ][ x ] )
        # sym_dep_test.push_back( coeff_dep_test[ d ][ x ] )
    # dep[ d ] = dot( coeff_dep_expr[ d ], base )
    # tep[ d ] = dot( coeff_dep_test[ d ], base )

# eps := e.grad_sym( dep )
# ept := e.grad_sym( tep )
# ene := eps : hooke_iso( 1, 0.3, e.dim ) : ept

# # ene += 1e3 * dot( dep, tep ).subs( e.var_inter, [ 0 0 ] )
# # ene += 1e3 * dot( dep - [ 0.1 0 ], tep ).subs( e.var_inter, [ 1 0 ] )
# def asym( m )
    # return m[0,1]-m[1,0]
# omega_e := asym( e.grad( dep ).subs(e.var_inter,e.var_inter*0) )
# omega_t := asym( e.grad( tep ).subs(e.var_inter,e.var_inter*0) )

# ene = e.integration( ene ) + omega_t * omega_e

# vec := ene.diff( sym_dep_test )
# mat := vec.diff( sym_dep_expr )
# vec *= -1

# res := ( mat \ vec ).subs( sym_dep_expr, sym_dep_expr * 0 )



# info Mat[Float64]( mat )

# info res
# info Vec[Float64]( dep.subs( sym_dep_expr, res ).subs( e.var_inter, [ 0 0 ] ) )
# info Vec[Float64]( dep.subs( sym_dep_expr, res ).subs( e.var_inter, [ 1 0 ] ) )
# info Vec[Float64]( dep.subs( sym_dep_expr, res ).subs( e.var_inter, [ 0 1 ] ) )


